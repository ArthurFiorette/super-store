// tslint:disable
/**
 * SE API Docs
 * ## Custom Variable types `guid` - string that matches pattern: `/^[0-9a-fA-F]{24}$/` (24 character hexadecimal string) `datetime` - either timestamp in miliseconds (unix timestamp*1000) or string in ISO 8061 format ## Global variables `Authorization` - string:  JWT Token you can obtain here: https://streamelements.com/dashboard/account/channels (click \"Show secrets\") `channelId` - guid: obtained by requesting `/channels/me` endpoint with provided JWT token `channelName` - string: lowercase channel name `timezone` - integer: timezone index
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessCodes
 */
export interface AccessCodes {
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessCodes
     */
    keys: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AccessCodes
     */
    mode: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessCodes
     */
    random: boolean;
}
/**
 * 
 * @export
 * @interface AdditionalMessagesBot
 */
export interface AdditionalMessagesBot {
    /**
     * 
     * @type {string}
     * @memberof AdditionalMessagesBot
     */
    _id: string;
    /**
     * 
     * @type {number}
     * @memberof AdditionalMessagesBot
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof AdditionalMessagesBot
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {Graphics8}
     * @memberof Alert
     */
    graphics: Graphics8;
    /**
     * 
     * @type {Audio1}
     * @memberof Alert
     */
    audio: Audio1;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    enabled: boolean;
}
/**
 * 
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * 
     * @type {number}
     * @memberof Amount
     */
    amount: number;
}
/**
 * 
 * @export
 * @interface AmountRecent
 */
export interface AmountRecent {
    /**
     * 
     * @type {string}
     * @memberof AmountRecent
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof AmountRecent
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof AmountRecent
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface Animation
 */
export interface Animation {
    /**
     * 
     * @type {string}
     * @memberof Animation
     */
    _in: string;
    /**
     * 
     * @type {string}
     * @memberof Animation
     */
    out: string;
    /**
     * 
     * @type {number}
     * @memberof Animation
     */
    timeout?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Animation
     */
    hide?: boolean;
}
/**
 * 
 * @export
 * @interface Announcements
 */
export interface Announcements {
    /**
     * 
     * @type {StreamStart}
     * @memberof Announcements
     */
    streamStart: StreamStart;
    /**
     * 
     * @type {boolean}
     * @memberof Announcements
     */
    enabled: boolean;
}
/**
 * 
 * @export
 * @interface Audio
 */
export interface Audio {
    /**
     * 
     * @type {string}
     * @memberof Audio
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof Audio
     */
    volume: number;
}
/**
 * 
 * @export
 * @interface Audio1
 */
export interface Audio1 {
    /**
     * 
     * @type {string}
     * @memberof Audio1
     */
    src: string | null;
    /**
     * 
     * @type {number}
     * @memberof Audio1
     */
    volume?: number;
}
/**
 * 
 * @export
 * @interface BackupPlaylist
 */
export interface BackupPlaylist {
    /**
     * 
     * @type {string}
     * @memberof BackupPlaylist
     */
    url: string;
    /**
     * 
     * @type {boolean}
     * @memberof BackupPlaylist
     */
    prioritizeQueue: boolean;
}
/**
 * 
 * @export
 * @interface Banphrases
 */
export interface Banphrases {
    /**
     * 
     * @type {boolean}
     * @memberof Banphrases
     */
    enabled: boolean;
}
/**
 * 
 * @export
 * @interface Banphrasesrequest
 */
export interface Banphrasesrequest {
    /**
     * 
     * @type {string}
     * @memberof Banphrasesrequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface Bingo
 */
export interface Bingo {
    /**
     * 
     * @type {boolean}
     * @memberof Bingo
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Bingo
     */
    maxAmount: number;
}
/**
 * 
 * @export
 * @interface Bonuses
 */
export interface Bonuses {
    /**
     * 
     * @type {number}
     * @memberof Bonuses
     */
    follow: number;
    /**
     * 
     * @type {number}
     * @memberof Bonuses
     */
    tip: number;
    /**
     * 
     * @type {number}
     * @memberof Bonuses
     */
    subscriber: number;
    /**
     * 
     * @type {number}
     * @memberof Bonuses
     */
    cheer: number;
    /**
     * 
     * @type {number}
     * @memberof Bonuses
     */
    host: number;
}
/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    joined: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    muted: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    mod: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Bot
     */
    allowCustomName: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    language: string;
    /**
     * 
     * @type {string}
     * @memberof Bot
     */
    channel: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Bot
     */
    logs: Array<string>;
}
/**
 * 
 * @export
 * @interface Bot1
 */
export interface Bot1 {
    /**
     * 
     * @type {Voteskip}
     * @memberof Bot1
     */
    voteskip: Voteskip;
    /**
     * 
     * @type {number}
     * @memberof Bot1
     */
    cost: number;
    /**
     * 
     * @type {number}
     * @memberof Bot1
     */
    subscriberDiscount: number;
    /**
     * 
     * @type {number}
     * @memberof Bot1
     */
    exemptUserLevel: number;
    /**
     * 
     * @type {number}
     * @memberof Bot1
     */
    minUserLevel: number;
}
/**
 * 
 * @export
 * @interface Bot2
 */
export interface Bot2 {
    /**
     * 
     * @type {boolean}
     * @memberof Bot2
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Bot2
     */
    identifier: string;
}
/**
 * 
 * @export
 * @interface BotCommand
 */
export interface BotCommand {
    /**
     * 
     * @type {Cooldown}
     * @memberof BotCommand
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotCommand
     */
    aliases: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotCommand
     */
    keywords: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BotCommand
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BotCommand
     */
    enabledOnline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BotCommand
     */
    enabledOffline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BotCommand
     */
    hidden: boolean;
    /**
     * 
     * @type {number}
     * @memberof BotCommand
     */
    cost: number;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof BotCommand
     */
    accessLevel: number;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    regex: string;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    reply: string;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    command: string;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof BotCommand
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface BotFilters
 */
export interface BotFilters {
    /**
     * 
     * @type {Caps}
     * @memberof BotFilters
     */
    caps: Caps;
    /**
     * 
     * @type {Links}
     * @memberof BotFilters
     */
    links: Links;
    /**
     * 
     * @type {Banphrases}
     * @memberof BotFilters
     */
    banphrases: Banphrases;
    /**
     * 
     * @type {Emotes}
     * @memberof BotFilters
     */
    emotes: Emotes;
    /**
     * 
     * @type {Symbols}
     * @memberof BotFilters
     */
    symbols: Symbols;
    /**
     * 
     * @type {Paragraph}
     * @memberof BotFilters
     */
    paragraph: Paragraph;
}
/**
 * 
 * @export
 * @interface BotJoinResponse
 */
export interface BotJoinResponse {
    /**
     * 
     * @type {number}
     * @memberof BotJoinResponse
     */
    status: number;
    /**
     * 
     * @type {string}
     * @memberof BotJoinResponse
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof BotJoinResponse
     */
    message: string;
}
/**
 * 
 * @export
 * @interface BotModules
 */
export interface BotModules {
    /**
     * 
     * @type {Roulette}
     * @memberof BotModules
     */
    roulette: Roulette;
    /**
     * 
     * @type {Raffle}
     * @memberof BotModules
     */
    raffle: Raffle;
    /**
     * 
     * @type {Pyramid}
     * @memberof BotModules
     */
    pyramid: Pyramid;
    /**
     * 
     * @type {Bingo}
     * @memberof BotModules
     */
    bingo: Bingo;
    /**
     * 
     * @type {Slotmachine}
     * @memberof BotModules
     */
    slotmachine: Slotmachine;
    /**
     * 
     * @type {Duel}
     * @memberof BotModules
     */
    duel: Duel;
    /**
     * 
     * @type {Eightball}
     * @memberof BotModules
     */
    eightball: Eightball;
    /**
     * 
     * @type {Emotecombo}
     * @memberof BotModules
     */
    emotecombo: Emotecombo;
    /**
     * 
     * @type {Twitter}
     * @memberof BotModules
     */
    twitter: Twitter;
    /**
     * 
     * @type {Chatalerts}
     * @memberof BotModules
     */
    chatalerts: Chatalerts;
    /**
     * 
     * @type {Songrequest}
     * @memberof BotModules
     */
    songrequest: Songrequest;
    /**
     * 
     * @type {Announcements}
     * @memberof BotModules
     */
    announcements: Announcements;
}
/**
 * 
 * @export
 * @interface BotSettings
 */
export interface BotSettings {
    /**
     * 
     * @type {Bot}
     * @memberof BotSettings
     */
    bot: Bot;
}
/**
 * 
 * @export
 * @interface BttvEmotes
 */
export interface BttvEmotes {
    /**
     * 
     * @type {Emote}
     * @memberof BttvEmotes
     */
    EmoteName?: Emote;
}
/**
 * 
 * @export
 * @interface Caps
 */
export interface Caps {
    /**
     * 
     * @type {Timeout}
     * @memberof Caps
     */
    timeout: Timeout;
    /**
     * 
     * @type {Settings}
     * @memberof Caps
     */
    settings: Settings;
    /**
     * 
     * @type {boolean}
     * @memberof Caps
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Caps
     */
    exclude: number;
}
/**
 * 
 * @export
 * @interface Channel1
 */
export interface Channel1 {
    /**
     * 
     * @type {Profile}
     * @memberof Channel1
     */
    profile: Profile;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    provider: string;
    /**
     * 
     * @type {boolean}
     * @memberof Channel1
     */
    suspended: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Channel1
     */
    nullChannel: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Channel1
     */
    providerEmails: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    lastJWTToken: string | null;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    avatar: string;
    /**
     * 
     * @type {boolean}
     * @memberof Channel1
     */
    verified: boolean;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    alias: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    providerId: string;
    /**
     * 
     * @type {boolean}
     * @memberof Channel1
     */
    isPartner: boolean;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    broadcasterType: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Channel1
     */
    ab: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    lastLogin: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof Channel1
     */
    role: string;
    /**
     * 
     * @type {Array<Moderator>}
     * @memberof Channel1
     */
    moderators: Array<Moderator>;
}
/**
 * 
 * @export
 * @interface ChannelData
 */
export interface ChannelData {
    /**
     * 
     * @type {SessionData}
     * @memberof ChannelData
     */
    data: SessionData;
    /**
     * 
     * @type {SessionSettings}
     * @memberof ChannelData
     */
    settings: SessionSettings;
    /**
     * 
     * @type {string}
     * @memberof ChannelData
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelData
     */
    lastReset: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelData
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelData
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelData
     */
    updatedAt: string;
    /**
     * 
     * @type {number}
     * @memberof ChannelData
     */
    __v: number;
}
/**
 * 
 * @export
 * @interface ChannelDetails
 */
export interface ChannelDetails {
    /**
     * 
     * @type {Profile}
     * @memberof ChannelDetails
     */
    profile: Profile;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    provider: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelDetails
     */
    suspended: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelDetails
     */
    nullChannel: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelDetails
     */
    providerEmails: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    lastJWTToken: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    avatar: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelDetails
     */
    verified: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    alias: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    providerId: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    apiToken: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelDetails
     */
    isPartner: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    broadcasterType: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof ChannelDetails
     */
    users: Array<User>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelDetails
     */
    ab: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    lastLogin: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelDetails
     */
    country: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelDetails
     */
    inactive: boolean;
}
/**
 * 
 * @export
 * @interface ChannelEmotes
 */
export interface ChannelEmotes {
    /**
     * 
     * @type {BttvEmotes}
     * @memberof ChannelEmotes
     */
    bttvChannelEmotes: BttvEmotes;
    /**
     * 
     * @type {BttvEmotes}
     * @memberof ChannelEmotes
     */
    bttvGlobalEmotes: BttvEmotes;
    /**
     * 
     * @type {string}
     * @memberof ChannelEmotes
     */
    ffzChannelEmotes: string | null;
    /**
     * 
     * @type {FfzGlobalEmotes}
     * @memberof ChannelEmotes
     */
    ffzGlobalEmotes: FfzGlobalEmotes;
    /**
     * 
     * @type {TwitchGlobalEmotes}
     * @memberof ChannelEmotes
     */
    twitchGlobalEmotes: TwitchGlobalEmotes;
    /**
     * 
     * @type {string}
     * @memberof ChannelEmotes
     */
    twitchSubEmotes: string | null;
}
/**
 * 
 * @export
 * @interface ChannelLanguagerequest
 */
export interface ChannelLanguagerequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelLanguagerequest
     */
    language: string;
}
/**
 * 
 * @export
 * @interface ChannelLevelsrequest
 */
export interface ChannelLevelsrequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelLevelsrequest
     */
    username: string;
    /**
     * 
     * @type {number}
     * @memberof ChannelLevelsrequest
     */
    level: number;
}
/**
 * 
 * @export
 * @interface ChannelModeration
 */
export interface ChannelModeration {
    /**
     * 
     * @type {Array<Recent>}
     * @memberof ChannelModeration
     */
    recent: Array<Recent>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChannelModeration
     */
    pending: Array<string>;
}
/**
 * 
 * @export
 * @interface ChannelQueuerequest
 */
export interface ChannelQueuerequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelQueuerequest
     */
    video: string;
}
/**
 * 
 * @export
 * @interface ChannelRedemptionsItemId
 */
export interface ChannelRedemptionsItemId {
    /**
     * 
     * @type {number}
     * @memberof ChannelRedemptionsItemId
     */
    statusCode: number;
    /**
     * 
     * @type {string}
     * @memberof ChannelRedemptionsItemId
     */
    error: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelRedemptionsItemId
     */
    message: string;
}
/**
 * 
 * @export
 * @interface ChannelReset
 */
export interface ChannelReset {
    /**
     * 
     * @type {SessionData}
     * @memberof ChannelReset
     */
    data: SessionData;
    /**
     * 
     * @type {SessionSettings}
     * @memberof ChannelReset
     */
    settings: SessionSettings;
    /**
     * 
     * @type {string}
     * @memberof ChannelReset
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelReset
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelReset
     */
    lastReset: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelReset
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelReset
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelReset
     */
    updatedAt: string;
    /**
     * 
     * @type {number}
     * @memberof ChannelReset
     */
    __v: number;
}
/**
 * 
 * @export
 * @interface ChannelSayrequest
 */
export interface ChannelSayrequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelSayrequest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface ChannelSettings
 */
export interface ChannelSettings {
    /**
     * 
     * @type {boolean}
     * @memberof ChannelSettings
     */
    autoReset: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelSettings
     */
    calendar: boolean;
}
/**
 * 
 * @export
 * @interface ChannelUsers
 */
export interface ChannelUsers {
    /**
     * 
     * @type {string}
     * @memberof ChannelUsers
     */
    channelId: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelUsers
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelUsers
     */
    avatar: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelUsers
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelUsers
     */
    role: string;
}
/**
 * 
 * @export
 * @interface Channelrequest
 */
export interface Channelrequest {
    /**
     * 
     * @type {Cooldown}
     * @memberof Channelrequest
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {Array<string>}
     * @memberof Channelrequest
     */
    aliases: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Channelrequest
     */
    keywords: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Channelrequest
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Channelrequest
     */
    enabledOnline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Channelrequest
     */
    enabledOffline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Channelrequest
     */
    hidden: boolean;
    /**
     * 
     * @type {number}
     * @memberof Channelrequest
     */
    cost: number;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof Channelrequest
     */
    accessLevel: number;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest
     */
    regex: string;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest
     */
    reply: string;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest
     */
    command: string;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest
     */
    channel: string;
}
/**
 * 
 * @export
 * @interface Channelrequest1
 */
export interface Channelrequest1 {
    /**
     * 
     * @type {Online}
     * @memberof Channelrequest1
     */
    online: Online;
    /**
     * 
     * @type {Offline}
     * @memberof Channelrequest1
     */
    offline: Offline;
    /**
     * 
     * @type {boolean}
     * @memberof Channelrequest1
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Channelrequest1
     */
    chatLines: number;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Channelrequest1
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Chatalerts
 */
export interface Chatalerts {
    /**
     * 
     * @type {FollowBot}
     * @memberof Chatalerts
     */
    follow: FollowBot;
    /**
     * 
     * @type {TipBot}
     * @memberof Chatalerts
     */
    tip: TipBot;
    /**
     * 
     * @type {HostBot}
     * @memberof Chatalerts
     */
    host: HostBot;
    /**
     * 
     * @type {SubscriberBot}
     * @memberof Chatalerts
     */
    subscriber: SubscriberBot;
    /**
     * 
     * @type {CheerBot}
     * @memberof Chatalerts
     */
    cheer: CheerBot;
    /**
     * 
     * @type {RedemptionBot}
     * @memberof Chatalerts
     */
    redemption: RedemptionBot;
    /**
     * 
     * @type {RaidBot}
     * @memberof Chatalerts
     */
    raid: RaidBot;
    /**
     * 
     * @type {boolean}
     * @memberof Chatalerts
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Chatalerts
     */
    delay: number;
}
/**
 * 
 * @export
 * @interface Cheer1
 */
export interface Cheer1 {
    /**
     * 
     * @type {boolean}
     * @memberof Cheer1
     */
    enableRandomPick: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Cheer1
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Cheer1
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof Cheer1
     */
    layout: string;
    /**
     * 
     * @type {Text1}
     * @memberof Cheer1
     */
    text: Text1;
    /**
     * 
     * @type {Graphics}
     * @memberof Cheer1
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof Cheer1
     */
    audio: Audio1;
    /**
     * 
     * @type {Animation}
     * @memberof Cheer1
     */
    animation: Animation;
    /**
     * 
     * @type {Array<Variation1>}
     * @memberof Cheer1
     */
    variations: Array<Variation1>;
    /**
     * 
     * @type {Tts}
     * @memberof Cheer1
     */
    tts: Tts;
}
/**
 * 
 * @export
 * @interface CheerAlertSettings
 */
export interface CheerAlertSettings {
    /**
     * 
     * @type {Graphics}
     * @memberof CheerAlertSettings
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof CheerAlertSettings
     */
    audio: Audio1;
    /**
     * 
     * @type {Text1}
     * @memberof CheerAlertSettings
     */
    text: Text1;
}
/**
 * 
 * @export
 * @interface CheerBot
 */
export interface CheerBot {
    /**
     * 
     * @type {boolean}
     * @memberof CheerBot
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<AdditionalMessagesBot>}
     * @memberof CheerBot
     */
    messages: Array<AdditionalMessagesBot>;
}
/**
 * 
 * @export
 * @interface CheerLatest
 */
export interface CheerLatest {
    /**
     * 
     * @type {string}
     * @memberof CheerLatest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CheerLatest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof CheerLatest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Command
 */
export interface Command {
    /**
     * 
     * @type {Cooldown}
     * @memberof Command
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {Array<string>}
     * @memberof Command
     */
    aliases: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Command
     */
    keywords: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Command
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Command
     */
    enabledOnline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Command
     */
    enabledOffline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Command
     */
    hidden: boolean;
    /**
     * 
     * @type {number}
     * @memberof Command
     */
    cost: number;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof Command
     */
    accessLevel: number;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    regex: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    reply: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    command: string;
    /**
     * 
     * @type {string}
     * @memberof Command
     */
    channel: string;
}
/**
 * 
 * @export
 * @interface Contest
 */
export interface Contest {
    /**
     * 
     * @type {boolean}
     * @memberof Contest
     */
    botResponses: boolean;
    /**
     * 
     * @type {number}
     * @memberof Contest
     */
    totalAmount: number;
    /**
     * 
     * @type {number}
     * @memberof Contest
     */
    totalUsers: number;
    /**
     * 
     * @type {string}
     * @memberof Contest
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Contest
     */
    title: string;
    /**
     * 
     * @type {number}
     * @memberof Contest
     */
    minBet: number;
    /**
     * 
     * @type {number}
     * @memberof Contest
     */
    maxBet: number;
    /**
     * 
     * @type {number}
     * @memberof Contest
     */
    duration: number;
    /**
     * 
     * @type {Array<Option>}
     * @memberof Contest
     */
    options: Array<Option>;
    /**
     * 
     * @type {string}
     * @memberof Contest
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Contest
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof Contest
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Contest
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Contests
 */
export interface Contests {
    /**
     * 
     * @type {string}
     * @memberof Contests
     */
    active: string | null;
    /**
     * 
     * @type {Array<Contest>}
     * @memberof Contests
     */
    contests: Array<Contest>;
}
/**
 * 
 * @export
 * @interface Cooldown
 */
export interface Cooldown {
    /**
     * 
     * @type {number}
     * @memberof Cooldown
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof Cooldown
     */
    global: number;
}
/**
 * 
 * @export
 * @interface Count
 */
export interface Count {
    /**
     * 
     * @type {number}
     * @memberof Count
     */
    count: number;
}
/**
 * 
 * @export
 * @interface Css
 */
export interface Css {
    /**
     * 
     * @type {number}
     * @memberof Css
     */
    z_index: number;
    /**
     * 
     * @type {string}
     * @memberof Css
     */
    top: string;
    /**
     * 
     * @type {string}
     * @memberof Css
     */
    left: string;
    /**
     * 
     * @type {string}
     * @memberof Css
     */
    width: string;
    /**
     * 
     * @type {string}
     * @memberof Css
     */
    height: string;
    /**
     * 
     * @type {number}
     * @memberof Css
     */
    opacity: number;
}
/**
 * 
 * @export
 * @interface Css1
 */
export interface Css1 {
    /**
     * 
     * @type {string}
     * @memberof Css1
     */
    position: string;
    /**
     * 
     * @type {number}
     * @memberof Css1
     */
    z_index: number;
    /**
     * 
     * @type {string}
     * @memberof Css1
     */
    font_family: string;
    /**
     * 
     * @type {number}
     * @memberof Css1
     */
    font_size: number;
    /**
     * 
     * @type {string}
     * @memberof Css1
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof Css1
     */
    font_weight: string;
    /**
     * 
     * @type {string}
     * @memberof Css1
     */
    text_shadow: string;
    /**
     * 
     * @type {string}
     * @memberof Css1
     */
    text_align: string;
    /**
     * 
     * @type {number}
     * @memberof Css1
     */
    line_height: number;
    /**
     * 
     * @type {Message}
     * @memberof Css1
     */
    message: Message;
}
/**
 * 
 * @export
 * @interface Css2
 */
export interface Css2 {
    /**
     * 
     * @type {string}
     * @memberof Css2
     */
    max_width: string;
}
/**
 * 
 * @export
 * @interface Css3
 */
export interface Css3 {
    /**
     * 
     * @type {number}
     * @memberof Css3
     */
    widget: number;
    /**
     * 
     * @type {number}
     * @memberof Css3
     */
    height: number;
}
/**
 * 
 * @export
 * @interface Css6
 */
export interface Css6 {
    /**
     * 
     * @type {number}
     * @memberof Css6
     */
    margin_top: number;
}
/**
 * 
 * @export
 * @interface Detail
 */
export interface Detail {
    /**
     * 
     * @type {Array<string>}
     * @memberof Detail
     */
    path: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Detail
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Donation
 */
export interface Donation {
    /**
     * 
     * @type {DonationUser}
     * @memberof Donation
     */
    user: DonationUser;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof Donation
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof Donation
     */
    currency: string;
}
/**
 * 
 * @export
 * @interface DonationUser
 */
export interface DonationUser {
    /**
     * 
     * @type {string}
     * @memberof DonationUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof DonationUser
     */
    ip?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DonationUser
     */
    geo: string | null;
    /**
     * 
     * @type {string}
     * @memberof DonationUser
     */
    email: string;
}
/**
 * 
 * @export
 * @interface Duel
 */
export interface Duel {
    /**
     * 
     * @type {Cooldown}
     * @memberof Duel
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {Messages5}
     * @memberof Duel
     */
    messages: Messages5;
    /**
     * 
     * @type {boolean}
     * @memberof Duel
     */
    enabled: boolean;
}
/**
 * 
 * @export
 * @interface Eightball
 */
export interface Eightball {
    /**
     * 
     * @type {Cooldown}
     * @memberof Eightball
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {boolean}
     * @memberof Eightball
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Eightball
     */
    messages: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Eightball
     */
    emotes: Array<string>;
}
/**
 * 
 * @export
 * @interface Emote
 */
export interface Emote {
    /**
     * 
     * @type {string}
     * @memberof Emote
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Emote
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Emote
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof Emote
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof Emote
     */
    height: number;
    /**
     * 
     * @type {boolean}
     * @memberof Emote
     */
    gif: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Emote
     */
    urls: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Emotecombo
 */
export interface Emotecombo {
    /**
     * 
     * @type {boolean}
     * @memberof Emotecombo
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Emotecombo
     */
    minCount: number;
    /**
     * 
     * @type {number}
     * @memberof Emotecombo
     */
    cooldown: number;
    /**
     * 
     * @type {Array<Messages6>}
     * @memberof Emotecombo
     */
    messages: Array<Messages6>;
}
/**
 * 
 * @export
 * @interface Emotes
 */
export interface Emotes {
    /**
     * 
     * @type {Timeout}
     * @memberof Emotes
     */
    timeout: Timeout;
    /**
     * 
     * @type {TimeoutSettings}
     * @memberof Emotes
     */
    settings: TimeoutSettings;
    /**
     * 
     * @type {boolean}
     * @memberof Emotes
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Emotes
     */
    exclude: number;
}
/**
 * 
 * @export
 * @interface FfzGlobalEmotes
 */
export interface FfzGlobalEmotes {
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    AndKnuckles?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    BORT?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    BeanieHipster?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    CatBag?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    LaterSooner?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    LilZ?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    ManChicken?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    OBOY?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    OiMinna?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    YellowFever?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    YooHoo?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    ZliL?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    ZrehplaR?: Emote;
    /**
     * 
     * @type {Emote}
     * @memberof FfzGlobalEmotes
     */
    ZreknarF?: Emote;
}
/**
 * 
 * @export
 * @interface FollowBot
 */
export interface FollowBot {
    /**
     * 
     * @type {boolean}
     * @memberof FollowBot
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof FollowBot
     */
    messages: Array<string>;
}
/**
 * 
 * @export
 * @interface Follower
 */
export interface Follower {
    /**
     * 
     * @type {boolean}
     * @memberof Follower
     */
    enableRandomPick: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Follower
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Follower
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof Follower
     */
    layout: string;
    /**
     * 
     * @type {Text1}
     * @memberof Follower
     */
    text: Text1;
    /**
     * 
     * @type {Graphics}
     * @memberof Follower
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof Follower
     */
    audio: Audio1;
    /**
     * 
     * @type {Animation}
     * @memberof Follower
     */
    animation: Animation;
    /**
     * 
     * @type {Array<string>}
     * @memberof Follower
     */
    variations: Array<string>;
}
/**
 * 
 * @export
 * @interface FollowerLatest
 */
export interface FollowerLatest {
    /**
     * 
     * @type {string}
     * @memberof FollowerLatest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface FollowerRecent
 */
export interface FollowerRecent {
    /**
     * 
     * @type {string}
     * @memberof FollowerRecent
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FollowerRecent
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface Giveaway
 */
export interface Giveaway {
    /**
     * 
     * @type {number}
     * @memberof Giveaway
     */
    subscriberLuck: number;
    /**
     * 
     * @type {boolean}
     * @memberof Giveaway
     */
    subscriberOnly: boolean;
    /**
     * 
     * @type {number}
     * @memberof Giveaway
     */
    totalAmount: number;
    /**
     * 
     * @type {number}
     * @memberof Giveaway
     */
    totalUsers: number;
    /**
     * 
     * @type {boolean}
     * @memberof Giveaway
     */
    botResponses: boolean;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    _id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Giveaway
     */
    winners: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    startedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Giveaway
     */
    endedAt?: string;
}
/**
 * 
 * @export
 * @interface GiveawayUserList
 */
export interface GiveawayUserList {
    /**
     * 
     * @type {boolean}
     * @memberof GiveawayUserList
     */
    entered: boolean;
    /**
     * 
     * @type {number}
     * @memberof GiveawayUserList
     */
    tickets: number;
    /**
     * 
     * @type {string}
     * @memberof GiveawayUserList
     */
    username: string;
    /**
     * 
     * @type {boolean}
     * @memberof GiveawayUserList
     */
    subscriber: boolean;
}
/**
 * 
 * @export
 * @interface Giveaways
 */
export interface Giveaways {
    /**
     * 
     * @type {string}
     * @memberof Giveaways
     */
    active: string | null;
    /**
     * 
     * @type {Array<Giveaway>}
     * @memberof Giveaways
     */
    giveaways: Array<Giveaway>;
}
/**
 * 
 * @export
 * @interface Graphics
 */
export interface Graphics {
    /**
     * 
     * @type {string}
     * @memberof Graphics
     */
    src: string | null;
    /**
     * 
     * @type {string}
     * @memberof Graphics
     */
    type: string;
}
/**
 * 
 * @export
 * @interface Graphics8
 */
export interface Graphics8 {
    /**
     * 
     * @type {number}
     * @memberof Graphics8
     */
    duration: number;
}
/**
 * 
 * @export
 * @interface Highlights
 */
export interface Highlights {
    /**
     * 
     * @type {string}
     * @memberof Highlights
     */
    color: string;
}
/**
 * 
 * @export
 * @interface Host1
 */
export interface Host1 {
    /**
     * 
     * @type {boolean}
     * @memberof Host1
     */
    enableRandomPick: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Host1
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Host1
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof Host1
     */
    layout: string;
    /**
     * 
     * @type {Text1}
     * @memberof Host1
     */
    text: Text1;
    /**
     * 
     * @type {Graphics}
     * @memberof Host1
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof Host1
     */
    audio: Audio1;
    /**
     * 
     * @type {Animation}
     * @memberof Host1
     */
    animation: Animation;
    /**
     * 
     * @type {Array<string>}
     * @memberof Host1
     */
    variations: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Host1
     */
    minAmount: number;
}
/**
 * 
 * @export
 * @interface HostBot
 */
export interface HostBot {
    /**
     * 
     * @type {boolean}
     * @memberof HostBot
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<AdditionalMessagesBot>}
     * @memberof HostBot
     */
    messages: Array<AdditionalMessagesBot>;
}
/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    type: string;
    /**
     * 
     * @type {Css2}
     * @memberof Image
     */
    css: Css2;
}
/**
 * 
 * @export
 * @interface Limits
 */
export interface Limits {
    /**
     * 
     * @type {Users}
     * @memberof Limits
     */
    users: Users;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    queueLimit: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    maxDuration: number;
}
/**
 * 
 * @export
 * @interface LinkedChannels
 */
export interface LinkedChannels {
    /**
     * 
     * @type {Profile}
     * @memberof LinkedChannels
     */
    profile: Profile;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    provider: string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkedChannels
     */
    suspended: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LinkedChannels
     */
    nullChannel: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LinkedChannels
     */
    providerEmails: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    lastJWTToken: string | null;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    avatar: string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkedChannels
     */
    verified: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    alias: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    providerId: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    apiToken: string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkedChannels
     */
    isPartner: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    broadcasterType: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof LinkedChannels
     */
    users: Array<User>;
    /**
     * 
     * @type {object}
     * @memberof LinkedChannels
     */
    ab: object;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    lastLogin: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    country: string;
    /**
     * 
     * @type {ProviderTotals}
     * @memberof LinkedChannels
     */
    providerTotals: ProviderTotals;
    /**
     * 
     * @type {object}
     * @memberof LinkedChannels
     */
    features: object;
    /**
     * 
     * @type {string}
     * @memberof LinkedChannels
     */
    geo: string;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {Timeout}
     * @memberof Links
     */
    timeout: Timeout;
    /**
     * 
     * @type {boolean}
     * @memberof Links
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Links
     */
    exclude: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Links
     */
    whitelist: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Links
     */
    blacklist: Array<string>;
}
/**
 * 
 * @export
 * @interface Listeners
 */
export interface Listeners {
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    tip_latest: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    subscriber_latest: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    follower_latest: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    cheer_latest: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    host_latest: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    raid_latest: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Listeners
     */
    redemption_latest?: boolean;
}
/**
 * 
 * @export
 * @interface Loyalty
 */
export interface Loyalty {
    /**
     * 
     * @type {Bonuses}
     * @memberof Loyalty
     */
    bonuses: Bonuses;
    /**
     * 
     * @type {string}
     * @memberof Loyalty
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Loyalty
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Loyalty
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof Loyalty
     */
    subscriberMultiplier: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Loyalty
     */
    ignored: Array<string>;
}
/**
 * 
 * @export
 * @interface LoyaltyItem
 */
export interface LoyaltyItem {
    /**
     * 
     * @type {Bot2}
     * @memberof LoyaltyItem
     */
    bot: Bot2;
    /**
     * 
     * @type {Cooldown}
     * @memberof LoyaltyItem
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {Quantity1}
     * @memberof LoyaltyItem
     */
    quantity: Quantity1;
    /**
     * 
     * @type {AccessCodes}
     * @memberof LoyaltyItem
     */
    accessCodes?: AccessCodes;
    /**
     * 
     * @type {Alert}
     * @memberof LoyaltyItem
     */
    alert: Alert;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyItem
     */
    subscriberOnly: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoyaltyItem
     */
    userInput: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    _id: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyItem
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyItem
     */
    featured: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    type: string;
    /**
     * 
     * @type {number}
     * @memberof LoyaltyItem
     */
    cost: number;
    /**
     * 
     * @type {boolean}
     * @memberof LoyaltyItem
     */
    _public: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof LoyaltyItem
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface MediaRequestData
 */
export interface MediaRequestData {
    /**
     * 
     * @type {Player}
     * @memberof MediaRequestData
     */
    player: Player;
    /**
     * 
     * @type {Limits}
     * @memberof MediaRequestData
     */
    limits: Limits;
    /**
     * 
     * @type {BackupPlaylist}
     * @memberof MediaRequestData
     */
    backupPlaylist: BackupPlaylist;
    /**
     * 
     * @type {Bot1}
     * @memberof MediaRequestData
     */
    bot: Bot1;
    /**
     * 
     * @type {Tips}
     * @memberof MediaRequestData
     */
    tips: Tips;
    /**
     * 
     * @type {Youtube}
     * @memberof MediaRequestData
     */
    youtube: Youtube;
    /**
     * 
     * @type {boolean}
     * @memberof MediaRequestData
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaRequestData
     */
    mode: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaRequestData
     */
    moderation: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaRequestData
     */
    _id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaRequestData
     */
    bannedUsers: Array<string>;
}
/**
 * 
 * @export
 * @interface MediaRequestQueue
 */
export interface MediaRequestQueue {
    /**
     * 
     * @type {number}
     * @memberof MediaRequestQueue
     */
    limit: number;
    /**
     * 
     * @type {string}
     * @memberof MediaRequestQueue
     */
    nextPage: string;
    /**
     * 
     * @type {number}
     * @memberof MediaRequestQueue
     */
    total: number;
    /**
     * 
     * @type {Array<Video1>}
     * @memberof MediaRequestQueue
     */
    videos: Array<Video1>;
}
/**
 * 
 * @export
 * @interface Mediashare
 */
export interface Mediashare {
    /**
     * 
     * @type {boolean}
     * @memberof Mediashare
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Mediashare
     */
    costPerSecond: number;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    enableShadow: boolean;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    font_family: string;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    font_size: number;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    line_height: number;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    text_align: string;
}
/**
 * 
 * @export
 * @interface Message1
 */
export interface Message1 {
    /**
     * 
     * @type {number}
     * @memberof Message1
     */
    font_size: number;
    /**
     * 
     * @type {string}
     * @memberof Message1
     */
    font_family: string;
    /**
     * 
     * @type {string}
     * @memberof Message1
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof Message1
     */
    text_shadow: string;
    /**
     * 
     * @type {string}
     * @memberof Message1
     */
    text_align: string;
    /**
     * 
     * @type {string}
     * @memberof Message1
     */
    margin: string;
}
/**
 * 
 * @export
 * @interface Messages5
 */
export interface Messages5 {
    /**
     * 
     * @type {string}
     * @memberof Messages5
     */
    win: string;
    /**
     * 
     * @type {string}
     * @memberof Messages5
     */
    pointsWin: string;
}
/**
 * 
 * @export
 * @interface Messages6
 */
export interface Messages6 {
    /**
     * 
     * @type {string}
     * @memberof Messages6
     */
    _id: string;
    /**
     * 
     * @type {number}
     * @memberof Messages6
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof Messages6
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Model400Badrequest
 */
export interface Model400Badrequest {
    /**
     * 
     * @type {number}
     * @memberof Model400Badrequest
     */
    statusCode: number;
    /**
     * 
     * @type {string}
     * @memberof Model400Badrequest
     */
    error: string;
    /**
     * 
     * @type {string}
     * @memberof Model400Badrequest
     */
    message: string;
    /**
     * 
     * @type {Array<Detail>}
     * @memberof Model400Badrequest
     */
    details: Array<Detail>;
}
/**
 * 
 * @export
 * @interface Moderator
 */
export interface Moderator {
    /**
     * 
     * @type {User13}
     * @memberof Moderator
     */
    user: User13;
    /**
     * 
     * @type {string}
     * @memberof Moderator
     */
    role: string;
}
/**
 * 
 * @export
 * @interface Multi
 */
export interface Multi {
    /**
     * 
     * @type {SingleRaffleMessages}
     * @memberof Multi
     */
    messages: SingleRaffleMessages;
    /**
     * 
     * @type {number}
     * @memberof Multi
     */
    duration: number;
    /**
     * 
     * @type {number}
     * @memberof Multi
     */
    maxAmount: number;
}
/**
 * 
 * @export
 * @interface NewTip
 */
export interface NewTip {
    /**
     * 
     * @type {User11}
     * @memberof NewTip
     */
    user: User11;
    /**
     * 
     * @type {string}
     * @memberof NewTip
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof NewTip
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof NewTip
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof NewTip
     */
    currency: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewTip
     */
    imported: boolean;
}
/**
 * 
 * @export
 * @interface Notfound2
 */
export interface Notfound2 {
    /**
     * 
     * @type {number}
     * @memberof Notfound2
     */
    statusCode: number;
    /**
     * 
     * @type {string}
     * @memberof Notfound2
     */
    error: string;
}
/**
 * 
 * @export
 * @interface Offline
 */
export interface Offline {
    /**
     * 
     * @type {boolean}
     * @memberof Offline
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Offline
     */
    interval: number;
}
/**
 * 
 * @export
 * @interface Online
 */
export interface Online {
    /**
     * 
     * @type {boolean}
     * @memberof Online
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Online
     */
    interval: number;
}
/**
 * 
 * @export
 * @interface Option
 */
export interface Option {
    /**
     * 
     * @type {number}
     * @memberof Option
     */
    totalAmount: number;
    /**
     * 
     * @type {number}
     * @memberof Option
     */
    totalUsers: number;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    command: string;
}
/**
 * 
 * @export
 * @interface Overlay
 */
export interface Overlay {
    /**
     * 
     * @type {string}
     * @memberof Overlay
     */
    overlay: string;
    /**
     * 
     * @type {string}
     * @memberof Overlay
     */
    thumbnail: string;
    /**
     * 
     * @type {string}
     * @memberof Overlay
     */
    preview: string;
    /**
     * 
     * @type {string}
     * @memberof Overlay
     */
    _id: string;
}
/**
 * 
 * @export
 * @interface OverlayData
 */
export interface OverlayData {
    /**
     * 
     * @type {OverlaySettings}
     * @memberof OverlayData
     */
    settings: OverlaySettings;
    /**
     * 
     * @type {Widget}
     * @memberof OverlayData
     */
    widgets?: Widget;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    preview: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverlayData
     */
    mobile: boolean;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    game: string | null;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof OverlayData
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface OverlaySettings
 */
export interface OverlaySettings {
    /**
     * 
     * @type {number}
     * @memberof OverlaySettings
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof OverlaySettings
     */
    height: number;
    /**
     * 
     * @type {string}
     * @memberof OverlaySettings
     */
    name: string;
}
/**
 * 
 * @export
 * @interface OverlaysList
 */
export interface OverlaysList {
    /**
     * 
     * @type {number}
     * @memberof OverlaysList
     */
    total: number;
    /**
     * 
     * @type {Array<OverlayData>}
     * @memberof OverlaysList
     */
    docs: Array<OverlayData>;
}
/**
 * 
 * @export
 * @interface Paragraph
 */
export interface Paragraph {
    /**
     * 
     * @type {Timeout}
     * @memberof Paragraph
     */
    timeout: Timeout;
    /**
     * 
     * @type {TimeoutSettings}
     * @memberof Paragraph
     */
    settings: TimeoutSettings;
    /**
     * 
     * @type {boolean}
     * @memberof Paragraph
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Paragraph
     */
    exclude: number;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    delay: number;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    headerImage: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    title: string;
}
/**
 * 
 * @export
 * @interface ProviderTotals
 */
export interface ProviderTotals {
    /**
     * 
     * @type {number}
     * @memberof ProviderTotals
     */
    follower_total: number;
}
/**
 * 
 * @export
 * @interface Pyramid
 */
export interface Pyramid {
    /**
     * 
     * @type {boolean}
     * @memberof Pyramid
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<PyramidMessages>}
     * @memberof Pyramid
     */
    messages: Array<PyramidMessages>;
}
/**
 * 
 * @export
 * @interface PyramidMessages
 */
export interface PyramidMessages {
    /**
     * 
     * @type {string}
     * @memberof PyramidMessages
     */
    _id: string;
    /**
     * 
     * @type {number}
     * @memberof PyramidMessages
     */
    width: number;
    /**
     * 
     * @type {string}
     * @memberof PyramidMessages
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Quantity
 */
export interface Quantity {
    /**
     * 
     * @type {number}
     * @memberof Quantity
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof Quantity
     */
    current?: number;
}
/**
 * 
 * @export
 * @interface Quantity1
 */
export interface Quantity1 {
    /**
     * 
     * @type {number}
     * @memberof Quantity1
     */
    total: number;
}
/**
 * 
 * @export
 * @interface Raffle
 */
export interface Raffle {
    /**
     * 
     * @type {Single}
     * @memberof Raffle
     */
    single: Single;
    /**
     * 
     * @type {Multi}
     * @memberof Raffle
     */
    multi: Multi;
    /**
     * 
     * @type {boolean}
     * @memberof Raffle
     */
    enabled: boolean;
}
/**
 * 
 * @export
 * @interface RaffleMessages
 */
export interface RaffleMessages {
    /**
     * 
     * @type {string}
     * @memberof RaffleMessages
     */
    win: string;
    /**
     * 
     * @type {string}
     * @memberof RaffleMessages
     */
    lose: string;
    /**
     * 
     * @type {string}
     * @memberof RaffleMessages
     */
    allinWin: string;
    /**
     * 
     * @type {string}
     * @memberof RaffleMessages
     */
    allinLose: string;
}
/**
 * 
 * @export
 * @interface Raid1
 */
export interface Raid1 {
    /**
     * 
     * @type {boolean}
     * @memberof Raid1
     */
    enableRandomPick: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Raid1
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Raid1
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof Raid1
     */
    layout: string;
    /**
     * 
     * @type {Text1}
     * @memberof Raid1
     */
    text: Text1;
    /**
     * 
     * @type {Graphics}
     * @memberof Raid1
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof Raid1
     */
    audio: Audio1;
    /**
     * 
     * @type {Animation}
     * @memberof Raid1
     */
    animation: Animation;
    /**
     * 
     * @type {Array<string>}
     * @memberof Raid1
     */
    variations: Array<string>;
}
/**
 * 
 * @export
 * @interface RaidBot
 */
export interface RaidBot {
    /**
     * 
     * @type {boolean}
     * @memberof RaidBot
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<AdditionalMessagesBot>}
     * @memberof RaidBot
     */
    messages: Array<AdditionalMessagesBot>;
}
/**
 * 
 * @export
 * @interface Recent
 */
export interface Recent {
    /**
     * 
     * @type {Donation}
     * @memberof Recent
     */
    donation: Donation;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    status: string;
    /**
     * 
     * @type {boolean}
     * @memberof Recent
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    transactionId: string;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    approved: string;
    /**
     * 
     * @type {string}
     * @memberof Recent
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface RedemptionBot
 */
export interface RedemptionBot {
    /**
     * 
     * @type {boolean}
     * @memberof RedemptionBot
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof RedemptionBot
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Roulette
 */
export interface Roulette {
    /**
     * 
     * @type {Cooldown}
     * @memberof Roulette
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {RaffleMessages}
     * @memberof Roulette
     */
    messages: RaffleMessages;
    /**
     * 
     * @type {boolean}
     * @memberof Roulette
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Roulette
     */
    luck: number;
    /**
     * 
     * @type {number}
     * @memberof Roulette
     */
    minAmount: number;
}
/**
 * 
 * @export
 * @interface Scrolling
 */
export interface Scrolling {
    /**
     * 
     * @type {string}
     * @memberof Scrolling
     */
    direction: string;
    /**
     * 
     * @type {number}
     * @memberof Scrolling
     */
    speed: number;
}
/**
 * 
 * @export
 * @interface SessionData
 */
export interface SessionData {
    /**
     * 
     * @type {FollowerLatest}
     * @memberof SessionData
     */
    follower_latest: FollowerLatest;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    follower_session: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    follower_week: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    follower_month: Count;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    follower_goal: Amount;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    follower_total: Count;
    /**
     * 
     * @type {SubscriberLatest}
     * @memberof SessionData
     */
    subscriber_latest: SubscriberLatest;
    /**
     * 
     * @type {SubscriberNewLatest}
     * @memberof SessionData
     */
    subscriber_new_latest: SubscriberNewLatest;
    /**
     * 
     * @type {SubscriberResubLatest}
     * @memberof SessionData
     */
    subscriber_resub_latest: SubscriberResubLatest;
    /**
     * 
     * @type {SubscriberGiftedLatest}
     * @memberof SessionData
     */
    subscriber_gifted_latest: SubscriberGiftedLatest;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_session: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_new_session: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_resub_session: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_gifted_session: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_week: Count;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_month: Count;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    subscriber_goal: Amount;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    subscriber_total: Count;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    subscriber_points: Amount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    subscriber_alltime_gifter: TopUserAmount;
    /**
     * 
     * @type {AmountRecent}
     * @memberof SessionData
     */
    host_latest: AmountRecent;
    /**
     * 
     * @type {AmountRecent}
     * @memberof SessionData
     */
    raid_latest: AmountRecent;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    cheer_session: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    cheer_week: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    cheer_month: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    cheer_total: Amount;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    cheer_count: Count;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    cheer_goal: Amount;
    /**
     * 
     * @type {CheerLatest}
     * @memberof SessionData
     */
    cheer_latest: CheerLatest;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_session_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_weekly_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_monthly_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_alltime_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_session_top_donator: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_weekly_top_donator: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_monthly_top_donator: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    cheer_alltime_top_donator: TopUserAmount;
    /**
     * 
     * @type {TipLatest}
     * @memberof SessionData
     */
    tip_latest: TipLatest;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_session_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_weekly_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_monthly_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_alltime_top_donation: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_session_top_donator: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_weekly_top_donator: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_monthly_top_donator: TopUserAmount;
    /**
     * 
     * @type {TopUserAmount}
     * @memberof SessionData
     */
    tip_alltime_top_donator: TopUserAmount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    tip_session: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    tip_week: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    tip_month: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    tip_total: Amount;
    /**
     * 
     * @type {Count}
     * @memberof SessionData
     */
    tip_count: Count;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    tip_goal: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    merch_goal_orders: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    merch_goal_items: Amount;
    /**
     * 
     * @type {Amount}
     * @memberof SessionData
     */
    merch_goal_total: Amount;
    /**
     * 
     * @type {Array<FollowerRecent>}
     * @memberof SessionData
     */
    follower_recent: Array<FollowerRecent>;
    /**
     * 
     * @type {Array<SubscriberRecent>}
     * @memberof SessionData
     */
    subscriber_recent: Array<SubscriberRecent>;
    /**
     * 
     * @type {Array<AmountRecent>}
     * @memberof SessionData
     */
    host_recent: Array<AmountRecent>;
    /**
     * 
     * @type {Array<AmountRecent>}
     * @memberof SessionData
     */
    raid_recent: Array<AmountRecent>;
    /**
     * 
     * @type {Array<AmountRecent>}
     * @memberof SessionData
     */
    cheer_recent: Array<AmountRecent>;
    /**
     * 
     * @type {Array<AmountRecent>}
     * @memberof SessionData
     */
    tip_recent: Array<AmountRecent>;
    /**
     * 
     * @type {Array<AmountRecent>}
     * @memberof SessionData
     */
    merch_recent: Array<AmountRecent>;
}
/**
 * 
 * @export
 * @interface SessionDataInfo
 */
export interface SessionDataInfo {
    /**
     * 
     * @type {SessionData}
     * @memberof SessionDataInfo
     */
    data: SessionData;
    /**
     * 
     * @type {SessionSettings}
     * @memberof SessionDataInfo
     */
    settings: SessionSettings;
    /**
     * 
     * @type {string}
     * @memberof SessionDataInfo
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDataInfo
     */
    lastReset: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDataInfo
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDataInfo
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDataInfo
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof SessionDataInfo
     */
    updatedAt: string;
    /**
     * 
     * @type {number}
     * @memberof SessionDataInfo
     */
    __v: number;
}
/**
 * 
 * @export
 * @interface SessionSettings
 */
export interface SessionSettings {
    /**
     * 
     * @type {boolean}
     * @memberof SessionSettings
     */
    autoReset: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionSettings
     */
    calendar: boolean;
}
/**
 * 
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * 
     * @type {number}
     * @memberof Settings
     */
    limit: number;
    /**
     * 
     * @type {number}
     * @memberof Settings
     */
    min: number;
    /**
     * 
     * @type {number}
     * @memberof Settings
     */
    percent: number;
}
/**
 * 
 * @export
 * @interface SimpleChannelDetails
 */
export interface SimpleChannelDetails {
    /**
     * 
     * @type {Profile}
     * @memberof SimpleChannelDetails
     */
    profile: Profile;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    avatar: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    alias: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    providerId: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChannelDetails
     */
    isPartner: boolean;
    /**
     * 
     * @type {string}
     * @memberof SimpleChannelDetails
     */
    broadcasterType: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChannelDetails
     */
    inactive: boolean;
}
/**
 * 
 * @export
 * @interface Single
 */
export interface Single {
    /**
     * 
     * @type {SingleRaffleMessages}
     * @memberof Single
     */
    messages: SingleRaffleMessages;
    /**
     * 
     * @type {number}
     * @memberof Single
     */
    duration: number;
    /**
     * 
     * @type {number}
     * @memberof Single
     */
    maxAmount: number;
}
/**
 * 
 * @export
 * @interface SingleRaffleMessages
 */
export interface SingleRaffleMessages {
    /**
     * 
     * @type {string}
     * @memberof SingleRaffleMessages
     */
    start: string;
    /**
     * 
     * @type {string}
     * @memberof SingleRaffleMessages
     */
    running: string;
    /**
     * 
     * @type {string}
     * @memberof SingleRaffleMessages
     */
    end: string;
}
/**
 * 
 * @export
 * @interface Slotmachine
 */
export interface Slotmachine {
    /**
     * 
     * @type {Cooldown}
     * @memberof Slotmachine
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {SlotsMessages}
     * @memberof Slotmachine
     */
    messages: SlotsMessages;
    /**
     * 
     * @type {boolean}
     * @memberof Slotmachine
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Slotmachine
     */
    returnAmount: number;
    /**
     * 
     * @type {number}
     * @memberof Slotmachine
     */
    minAmount: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Slotmachine
     */
    emotes: Array<string>;
}
/**
 * 
 * @export
 * @interface SlotsMessages
 */
export interface SlotsMessages {
    /**
     * 
     * @type {string}
     * @memberof SlotsMessages
     */
    win: string;
    /**
     * 
     * @type {string}
     * @memberof SlotsMessages
     */
    lose: string;
}
/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {User2}
     * @memberof Song
     */
    user: User2;
    /**
     * 
     * @type {Statistics}
     * @memberof Song
     */
    statistics?: Statistics;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    duration: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Song
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Song
     */
    voteskips?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    videoId: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    source: string;
}
/**
 * 
 * @export
 * @interface Songrequest
 */
export interface Songrequest {
    /**
     * 
     * @type {Voteskip}
     * @memberof Songrequest
     */
    voteskip: Voteskip;
    /**
     * 
     * @type {boolean}
     * @memberof Songrequest
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Songrequest
     */
    moderation: boolean;
    /**
     * 
     * @type {number}
     * @memberof Songrequest
     */
    minUserLevel: number;
    /**
     * 
     * @type {number}
     * @memberof Songrequest
     */
    cost: number;
    /**
     * 
     * @type {number}
     * @memberof Songrequest
     */
    subscriberDiscount: number;
    /**
     * 
     * @type {number}
     * @memberof Songrequest
     */
    exemptUserLevel: number;
}
/**
 * 
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    viewCount: number;
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    likeCount: number;
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    dislikeCount: number;
}
/**
 * 
 * @export
 * @interface StreamStart
 */
export interface StreamStart {
    /**
     * 
     * @type {boolean}
     * @memberof StreamStart
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof StreamStart
     */
    message: string;
}
/**
 * 
 * @export
 * @interface SubVariationSettings
 */
export interface SubVariationSettings {
    /**
     * 
     * @type {string}
     * @memberof SubVariationSettings
     */
    layout: string;
    /**
     * 
     * @type {Text3}
     * @memberof SubVariationSettings
     */
    text: Text3;
    /**
     * 
     * @type {Graphics}
     * @memberof SubVariationSettings
     */
    graphics: Graphics;
}
/**
 * 
 * @export
 * @interface Subscriber1
 */
export interface Subscriber1 {
    /**
     * 
     * @type {boolean}
     * @memberof Subscriber1
     */
    enableRandomPick: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Subscriber1
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Subscriber1
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof Subscriber1
     */
    layout: string;
    /**
     * 
     * @type {Text1}
     * @memberof Subscriber1
     */
    text: Text1;
    /**
     * 
     * @type {Graphics}
     * @memberof Subscriber1
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof Subscriber1
     */
    audio: Audio1;
    /**
     * 
     * @type {Animation}
     * @memberof Subscriber1
     */
    animation: Animation;
    /**
     * 
     * @type {Array<Variation>}
     * @memberof Subscriber1
     */
    variations: Array<Variation>;
    /**
     * 
     * @type {Tts}
     * @memberof Subscriber1
     */
    tts: Tts;
}
/**
 * 
 * @export
 * @interface SubscriberBot
 */
export interface SubscriberBot {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriberBot
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<AdditionalMessagesBot>}
     * @memberof SubscriberBot
     */
    messages: Array<AdditionalMessagesBot>;
}
/**
 * 
 * @export
 * @interface SubscriberEvent
 */
export interface SubscriberEvent {
    /**
     * 
     * @type {string}
     * @memberof SubscriberEvent
     */
    username: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriberEvent
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriberEvent
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriberEvent
     */
    tier: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriberEvent
     */
    avatar: string;
}
/**
 * 
 * @export
 * @interface SubscriberGiftedLatest
 */
export interface SubscriberGiftedLatest {
    /**
     * 
     * @type {string}
     * @memberof SubscriberGiftedLatest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriberGiftedLatest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriberGiftedLatest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface SubscriberLatest
 */
export interface SubscriberLatest {
    /**
     * 
     * @type {string}
     * @memberof SubscriberLatest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriberLatest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriberLatest
     */
    tier: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriberLatest
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriberLatest
     */
    sender: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriberLatest
     */
    gifted: string | null;
}
/**
 * 
 * @export
 * @interface SubscriberNewLatest
 */
export interface SubscriberNewLatest {
    /**
     * 
     * @type {string}
     * @memberof SubscriberNewLatest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriberNewLatest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriberNewLatest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface SubscriberRecent
 */
export interface SubscriberRecent {
    /**
     * 
     * @type {string}
     * @memberof SubscriberRecent
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriberRecent
     */
    tier: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriberRecent
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriberRecent
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface SubscriberResubLatest
 */
export interface SubscriberResubLatest {
    /**
     * 
     * @type {string}
     * @memberof SubscriberResubLatest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriberResubLatest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriberResubLatest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Success
 */
export interface Success {
    /**
     * 
     * @type {SubscriberEvent}
     * @memberof Success
     */
    data: SubscriberEvent;
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Success
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface Success1
 */
export interface Success1 {
    /**
     * 
     * @type {number}
     * @memberof Success1
     */
    total: number;
    /**
     * 
     * @type {string}
     * @memberof Success1
     */
    username: string;
}
/**
 * 
 * @export
 * @interface Success11
 */
export interface Success11 {
    /**
     * 
     * @type {Online}
     * @memberof Success11
     */
    online: Online;
    /**
     * 
     * @type {Offline}
     * @memberof Success11
     */
    offline: Offline;
    /**
     * 
     * @type {boolean}
     * @memberof Success11
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Success11
     */
    chatLines: number;
    /**
     * 
     * @type {string}
     * @memberof Success11
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Success11
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Success11
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Success11
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Success11
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Success11
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Success16
 */
export interface Success16 {
    /**
     * 
     * @type {boolean}
     * @memberof Success16
     */
    _public: boolean;
    /**
     * 
     * @type {number}
     * @memberof Success16
     */
    excludeLevel: number;
    /**
     * 
     * @type {boolean}
     * @memberof Success16
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Success16
     */
    appliesTo: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Success16
     */
    runsOn: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Success16
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Success16
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Success16
     */
    phrases: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Success16
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Success16
     */
    lastUpdatedBy: string;
    /**
     * 
     * @type {string}
     * @memberof Success16
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Success16
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Success26
 */
export interface Success26 {
    /**
     * 
     * @type {number}
     * @memberof Success26
     */
    statusCode: number;
    /**
     * 
     * @type {string}
     * @memberof Success26
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Success27
 */
export interface Success27 {
    /**
     * 
     * @type {string}
     * @memberof Success27
     */
    counter: string;
    /**
     * 
     * @type {number}
     * @memberof Success27
     */
    value: number;
}
/**
 * 
 * @export
 * @interface Success3
 */
export interface Success3 {
    /**
     * 
     * @type {boolean}
     * @memberof Success3
     */
    success: boolean;
}
/**
 * 
 * @export
 * @interface Success40
 */
export interface Success40 {
    /**
     * 
     * @type {Loyalty}
     * @memberof Success40
     */
    loyalty: Loyalty;
    /**
     * 
     * @type {string}
     * @memberof Success40
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Success40
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof Success40
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Success40
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface Success44
 */
export interface Success44 {
    /**
     * 
     * @type {boolean}
     * @memberof Success44
     */
    ok: boolean;
}
/**
 * 
 * @export
 * @interface Success48
 */
export interface Success48 {
    /**
     * 
     * @type {boolean}
     * @memberof Success48
     */
    enabled: boolean;
    /**
     * 
     * @type {Limits}
     * @memberof Success48
     */
    limits: Limits;
    /**
     * 
     * @type {string}
     * @memberof Success48
     */
    mode: string;
    /**
     * 
     * @type {Tips}
     * @memberof Success48
     */
    tips: Tips;
    /**
     * 
     * @type {Youtube}
     * @memberof Success48
     */
    youtube: Youtube;
}
/**
 * 
 * @export
 * @interface Success53
 */
export interface Success53 {
    /**
     * 
     * @type {string}
     * @memberof Success53
     */
    state: string;
}
/**
 * 
 * @export
 * @interface Success6
 */
export interface Success6 {
    /**
     * 
     * @type {string}
     * @memberof Success6
     */
    commandId: string;
    /**
     * 
     * @type {string}
     * @memberof Success6
     */
    command: string;
    /**
     * 
     * @type {number}
     * @memberof Success6
     */
    accessLevel: number;
    /**
     * 
     * @type {boolean}
     * @memberof Success6
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Success6
     */
    enabledOnline: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Success6
     */
    enabledOffline: boolean;
    /**
     * 
     * @type {string}
     * @memberof Success6
     */
    moduleId: string;
    /**
     * 
     * @type {number}
     * @memberof Success6
     */
    cost: number;
    /**
     * 
     * @type {Cooldown}
     * @memberof Success6
     */
    cooldown: Cooldown;
    /**
     * 
     * @type {Array<string>}
     * @memberof Success6
     */
    aliases: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Success6
     */
    regex: string;
    /**
     * 
     * @type {string}
     * @memberof Success6
     */
    description: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Success6
     */
    subCommands?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Success6
     */
    moduleEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface Success64
 */
export interface Success64 {
    /**
     * 
     * @type {string}
     * @memberof Success64
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Success64
     */
    first: string;
    /**
     * 
     * @type {string}
     * @memberof Success64
     */
    last: string;
    /**
     * 
     * @type {number}
     * @memberof Success64
     */
    count: number;
    /**
     * 
     * @type {number}
     * @memberof Success64
     */
    total: number;
    /**
     * 
     * @type {string}
     * @memberof Success64
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof Success64
     */
    average: number;
}
/**
 * 
 * @export
 * @interface Success67
 */
export interface Success67 {
    /**
     * 
     * @type {boolean}
     * @memberof Success67
     */
    suspended: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Success67
     */
    teams: Array<string>;
    /**
     * 
     * @type {Array<Channel1>}
     * @memberof Success67
     */
    channels: Array<Channel1>;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    lastLogin: string;
    /**
     * 
     * @type {object}
     * @memberof Success67
     */
    ab: object;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    primaryChannel: string;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    avatar: string;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Success67
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface SuccessEmpty
 */
export interface SuccessEmpty {
    /**
     * 
     * @type {string}
     * @memberof SuccessEmpty
     */
    active: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SuccessEmpty
     */
    giveaways: Array<string>;
}
/**
 * 
 * @export
 * @interface SuccessSearchbysongname
 */
export interface SuccessSearchbysongname {
    /**
     * 
     * @type {string}
     * @memberof SuccessSearchbysongname
     */
    videoId: string;
    /**
     * 
     * @type {string}
     * @memberof SuccessSearchbysongname
     */
    thumbnail: string;
    /**
     * 
     * @type {string}
     * @memberof SuccessSearchbysongname
     */
    title: string;
}
/**
 * 
 * @export
 * @interface Symbols
 */
export interface Symbols {
    /**
     * 
     * @type {Timeout}
     * @memberof Symbols
     */
    timeout: Timeout;
    /**
     * 
     * @type {Settings}
     * @memberof Symbols
     */
    settings: Settings;
    /**
     * 
     * @type {boolean}
     * @memberof Symbols
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Symbols
     */
    exclude: number;
}
/**
 * 
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {string}
     * @memberof Text
     */
    type: string;
    /**
     * 
     * @type {boolean}
     * @memberof Text
     */
    enableShadow: boolean;
    /**
     * 
     * @type {Scrolling}
     * @memberof Text
     */
    scrolling: Scrolling;
    /**
     * 
     * @type {Css1}
     * @memberof Text
     */
    css: Css1;
}
/**
 * 
 * @export
 * @interface Text1
 */
export interface Text1 {
    /**
     * 
     * @type {string}
     * @memberof Text1
     */
    animation: string;
    /**
     * 
     * @type {TextCSS}
     * @memberof Text1
     */
    css: TextCSS;
    /**
     * 
     * @type {boolean}
     * @memberof Text1
     */
    enableShadow: boolean;
    /**
     * 
     * @type {string}
     * @memberof Text1
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Text3
 */
export interface Text3 {
    /**
     * 
     * @type {string}
     * @memberof Text3
     */
    message: string;
    /**
     * 
     * @type {Css6}
     * @memberof Text3
     */
    css?: Css6;
}
/**
 * 
 * @export
 * @interface TextCSS
 */
export interface TextCSS {
    /**
     * 
     * @type {string}
     * @memberof TextCSS
     */
    font_family: string;
    /**
     * 
     * @type {number}
     * @memberof TextCSS
     */
    font_size: number;
    /**
     * 
     * @type {string}
     * @memberof TextCSS
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof TextCSS
     */
    font_weight: string;
    /**
     * 
     * @type {string}
     * @memberof TextCSS
     */
    text_shadow: string;
    /**
     * 
     * @type {string}
     * @memberof TextCSS
     */
    text_align: string;
    /**
     * 
     * @type {Highlights}
     * @memberof TextCSS
     */
    highlights: Highlights;
    /**
     * 
     * @type {Message1}
     * @memberof TextCSS
     */
    message: Message1;
}
/**
 * 
 * @export
 * @interface ThemesList
 */
export interface ThemesList {
    /**
     * 
     * @type {boolean}
     * @memberof ThemesList
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    size: string;
    /**
     * 
     * @type {number}
     * @memberof ThemesList
     */
    totalUsers: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThemesList
     */
    mobile: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    game: string;
    /**
     * 
     * @type {string}
     * @memberof ThemesList
     */
    thumbnail: string;
    /**
     * 
     * @type {Array<Overlay>}
     * @memberof ThemesList
     */
    overlays: Array<Overlay>;
    /**
     * 
     * @type {number}
     * @memberof ThemesList
     */
    rating: number;
    /**
     * 
     * @type {boolean}
     * @memberof ThemesList
     */
    _new: boolean;
}
/**
 * 
 * @export
 * @interface Timeout
 */
export interface Timeout {
    /**
     * 
     * @type {number}
     * @memberof Timeout
     */
    length: number;
}
/**
 * 
 * @export
 * @interface TimeoutSettings
 */
export interface TimeoutSettings {
    /**
     * 
     * @type {number}
     * @memberof TimeoutSettings
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface Tip1
 */
export interface Tip1 {
    /**
     * 
     * @type {boolean}
     * @memberof Tip1
     */
    enableRandomPick: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Tip1
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Tip1
     */
    duration: number;
    /**
     * 
     * @type {string}
     * @memberof Tip1
     */
    layout: string;
    /**
     * 
     * @type {Text1}
     * @memberof Tip1
     */
    text: Text1;
    /**
     * 
     * @type {Graphics}
     * @memberof Tip1
     */
    graphics: Graphics;
    /**
     * 
     * @type {Audio1}
     * @memberof Tip1
     */
    audio: Audio1;
    /**
     * 
     * @type {Animation}
     * @memberof Tip1
     */
    animation: Animation;
    /**
     * 
     * @type {Array<string>}
     * @memberof Tip1
     */
    variations: Array<string>;
    /**
     * 
     * @type {Tts}
     * @memberof Tip1
     */
    tts: Tts;
}
/**
 * 
 * @export
 * @interface TipBot
 */
export interface TipBot {
    /**
     * 
     * @type {boolean}
     * @memberof TipBot
     */
    enabled: boolean;
    /**
     * 
     * @type {Array<AdditionalMessagesBot>}
     * @memberof TipBot
     */
    messages: Array<AdditionalMessagesBot>;
}
/**
 * 
 * @export
 * @interface TipData
 */
export interface TipData {
    /**
     * 
     * @type {Donation}
     * @memberof TipData
     */
    donation: Donation;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    status: string;
    /**
     * 
     * @type {boolean}
     * @memberof TipData
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    transactionId: string;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    approved: string;
    /**
     * 
     * @type {string}
     * @memberof TipData
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface TipLatest
 */
export interface TipLatest {
    /**
     * 
     * @type {string}
     * @memberof TipLatest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof TipLatest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TipLatest
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Tips
 */
export interface Tips {
    /**
     * 
     * @type {Mediashare}
     * @memberof Tips
     */
    mediashare: Mediashare;
    /**
     * 
     * @type {boolean}
     * @memberof Tips
     */
    prioritize: boolean;
}
/**
 * 
 * @export
 * @interface TopUserAmount
 */
export interface TopUserAmount {
    /**
     * 
     * @type {string}
     * @memberof TopUserAmount
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof TopUserAmount
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TopUserAmount
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Tts
 */
export interface Tts {
    /**
     * 
     * @type {boolean}
     * @memberof Tts
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tts
     */
    voice: string;
    /**
     * 
     * @type {number}
     * @memberof Tts
     */
    volume: number;
    /**
     * 
     * @type {number}
     * @memberof Tts
     */
    minAmount: number;
}
/**
 * 
 * @export
 * @interface TwitchGlobalEmotes
 */
export interface TwitchGlobalEmotes {
    /**
     * 
     * @type {Emote}
     * @memberof TwitchGlobalEmotes
     */
    EmoteName?: Emote;
}
/**
 * 
 * @export
 * @interface Twitter
 */
export interface Twitter {
    /**
     * 
     * @type {boolean}
     * @memberof Twitter
     */
    enabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Twitter
     */
    replies: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Twitter
     */
    retweets: boolean;
    /**
     * 
     * @type {string}
     * @memberof Twitter
     */
    template: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Twitter
     */
    followed: Array<string>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    user: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    providerId: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role: string;
}
/**
 * 
 * @export
 * @interface User11
 */
export interface User11 {
    /**
     * 
     * @type {string}
     * @memberof User11
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof User11
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User11
     */
    email: string;
}
/**
 * 
 * @export
 * @interface User13
 */
export interface User13 {
    /**
     * 
     * @type {string}
     * @memberof User13
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof User13
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User13
     */
    avatar: string;
}
/**
 * 
 * @export
 * @interface User2
 */
export interface User2 {
    /**
     * 
     * @type {string}
     * @memberof User2
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User2
     */
    providerId: string;
}
/**
 * 
 * @export
 * @interface UserLevel
 */
export interface UserLevel {
    /**
     * 
     * @type {string}
     * @memberof UserLevel
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserLevel
     */
    lastActive: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserLevel
     */
    moderator: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserLevel
     */
    subscriber: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserLevel
     */
    level: number;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    free: number;
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    paid: number;
}
/**
 * 
 * @export
 * @interface Variables
 */
export interface Variables {
    /**
     * 
     * @type {string}
     * @memberof Variables
     */
    css?: string;
    /**
     * 
     * @type {string}
     * @memberof Variables
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof Variables
     */
    js?: string;
    /**
     * 
     * @type {Follower}
     * @memberof Variables
     */
    follower?: Follower;
    /**
     * 
     * @type {Subscriber1}
     * @memberof Variables
     */
    subscriber?: Subscriber1;
    /**
     * 
     * @type {Tip1}
     * @memberof Variables
     */
    tip?: Tip1;
    /**
     * 
     * @type {Host1}
     * @memberof Variables
     */
    host?: Host1;
    /**
     * 
     * @type {Raid1}
     * @memberof Variables
     */
    raid?: Raid1;
    /**
     * 
     * @type {Cheer1}
     * @memberof Variables
     */
    cheer?: Cheer1;
}
/**
 * 
 * @export
 * @interface Variation
 */
export interface Variation {
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    condition?: string;
    /**
     * 
     * @type {number}
     * @memberof Variation
     */
    requirement?: number;
    /**
     * 
     * @type {SubVariationSettings}
     * @memberof Variation
     */
    settings: SubVariationSettings;
}
/**
 * 
 * @export
 * @interface Variation1
 */
export interface Variation1 {
    /**
     * 
     * @type {string}
     * @memberof Variation1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Variation1
     */
    condition: string;
    /**
     * 
     * @type {number}
     * @memberof Variation1
     */
    requirement: number;
    /**
     * 
     * @type {string}
     * @memberof Variation1
     */
    layout?: string;
    /**
     * 
     * @type {CheerAlertSettings}
     * @memberof Variation1
     */
    settings: CheerAlertSettings;
}
/**
 * 
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    type: string;
    /**
     * 
     * @type {Css3}
     * @memberof Video
     */
    css: Css3;
}
/**
 * 
 * @export
 * @interface Video1
 */
export interface Video1 {
    /**
     * 
     * @type {string}
     * @memberof Video1
     */
    videoId: string;
    /**
     * 
     * @type {string}
     * @memberof Video1
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Video1
     */
    channel: string;
}
/**
 * 
 * @export
 * @interface Voteskip
 */
export interface Voteskip {
    /**
     * 
     * @type {boolean}
     * @memberof Voteskip
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof Voteskip
     */
    votesRequired: number;
}
/**
 * 
 * @export
 * @interface Widget
 */
export interface Widget {
    /**
     * 
     * @type {number}
     * @memberof Widget
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    type: string;
    /**
     * 
     * @type {boolean}
     * @memberof Widget
     */
    visible: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Widget
     */
    locked: boolean;
    /**
     * 
     * @type {Listeners}
     * @memberof Widget
     */
    listeners: Listeners;
    /**
     * 
     * @type {Css}
     * @memberof Widget
     */
    css: Css;
    /**
     * 
     * @type {Text}
     * @memberof Widget
     */
    text: Text;
    /**
     * 
     * @type {Image}
     * @memberof Widget
     */
    image: Image;
    /**
     * 
     * @type {Video}
     * @memberof Widget
     */
    video: Video;
    /**
     * 
     * @type {Audio}
     * @memberof Widget
     */
    audio: Audio;
    /**
     * 
     * @type {Animation}
     * @memberof Widget
     */
    animation: Animation;
    /**
     * 
     * @type {Variables}
     * @memberof Widget
     */
    variables: Variables;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    provider: string;
    /**
     * 
     * @type {boolean}
     * @memberof Widget
     */
    staffOnly: boolean;
    /**
     * 
     * @type {number}
     * @memberof Widget
     */
    version?: number;
}
/**
 * 
 * @export
 * @interface Youtube
 */
export interface Youtube {
    /**
     * 
     * @type {number}
     * @memberof Youtube
     */
    securityLevel?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Youtube
     */
    musicOnly: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Youtube
     */
    bannedTags?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Youtube
     */
    bannedVideos?: Array<string>;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List channel activities
         * @summary /:channel
         * @param {number} after datetime - Start date
         * @param {number} before datetime - End date
         * @param {number} limit integer - events per page between 1 and 100
         * @param {number} mincheer integer - minimum amount of bits in cheer
         * @param {number} minhost integer - minimum amount of viewers in host
         * @param {number} minsub integer - minimum amount of subscription\&#39;s months
         * @param {number} mintip integer - minimum amount of tip
         * @param {string} origin 
         * @param {string} types array - Possible values: follow, tip, host, cheer, redemption, raid, superchat, sponsor, merch
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel: async (after: number, before: number, limit: number, mincheer: number, minhost: number, minsub: number, mintip: number, origin: string, types: string, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'after' is not null or undefined
            if (after === null || after === undefined) {
                throw new RequiredError('after','Required parameter after was null or undefined when calling channel.');
            }
            // verify required parameter 'before' is not null or undefined
            if (before === null || before === undefined) {
                throw new RequiredError('before','Required parameter before was null or undefined when calling channel.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channel.');
            }
            // verify required parameter 'mincheer' is not null or undefined
            if (mincheer === null || mincheer === undefined) {
                throw new RequiredError('mincheer','Required parameter mincheer was null or undefined when calling channel.');
            }
            // verify required parameter 'minhost' is not null or undefined
            if (minhost === null || minhost === undefined) {
                throw new RequiredError('minhost','Required parameter minhost was null or undefined when calling channel.');
            }
            // verify required parameter 'minsub' is not null or undefined
            if (minsub === null || minsub === undefined) {
                throw new RequiredError('minsub','Required parameter minsub was null or undefined when calling channel.');
            }
            // verify required parameter 'mintip' is not null or undefined
            if (mintip === null || mintip === undefined) {
                throw new RequiredError('mintip','Required parameter mintip was null or undefined when calling channel.');
            }
            // verify required parameter 'origin' is not null or undefined
            if (origin === null || origin === undefined) {
                throw new RequiredError('origin','Required parameter origin was null or undefined when calling channel.');
            }
            // verify required parameter 'types' is not null or undefined
            if (types === null || types === undefined) {
                throw new RequiredError('types','Required parameter types was null or undefined when calling channel.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channel.');
            }
            const localVarPath = `/activities/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mincheer !== undefined) {
                localVarQueryParameter['mincheer'] = mincheer;
            }

            if (minhost !== undefined) {
                localVarQueryParameter['minhost'] = minhost;
            }

            if (minsub !== undefined) {
                localVarQueryParameter['minsub'] = minsub;
            }

            if (mintip !== undefined) {
                localVarQueryParameter['mintip'] = mintip;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get activity details by id
         * @summary /:channel/:activityId
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActivityId: async (channel: string, activityId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelActivityId.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId','Required parameter activityId was null or undefined when calling channelActivityId.');
            }
            const localVarPath = `/activities/{channel}/{activityId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update activity id
         * @summary /:channel/:activityId1
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActivityId1: async (channel: string, activityId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelActivityId1.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId','Required parameter activityId was null or undefined when calling channelActivityId1.');
            }
            const localVarPath = `/activities/{channel}/{activityId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replay activity
         * @summary /:channel/:activityId/replay
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActivityIdReplay: async (channel: string, activityId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelActivityIdReplay.');
            }
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId','Required parameter activityId was null or undefined when calling channelActivityIdReplay.');
            }
            const localVarPath = `/activities/{channel}/{activityId}/replay`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List channel\'s top activities by selected type
         * @summary /:channel/top
         * @param {number} offset integer - starting element
         * @param {number} limit integer - number of events
         * @param {string} type string - Possible values: cheer, tip
         * @param {string} period string - Possible values: alltime, months, weeks, session
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTop: async (offset: number, limit: number, type: string, period: string, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelTop.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelTop.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling channelTop.');
            }
            // verify required parameter 'period' is not null or undefined
            if (period === null || period === undefined) {
                throw new RequiredError('period','Required parameter period was null or undefined when calling channelTop.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelTop.');
            }
            const localVarPath = `/activities/{channel}/top`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List channel activities
         * @summary /:channel
         * @param {number} after datetime - Start date
         * @param {number} before datetime - End date
         * @param {number} limit integer - events per page between 1 and 100
         * @param {number} mincheer integer - minimum amount of bits in cheer
         * @param {number} minhost integer - minimum amount of viewers in host
         * @param {number} minsub integer - minimum amount of subscription\&#39;s months
         * @param {number} mintip integer - minimum amount of tip
         * @param {string} origin 
         * @param {string} types array - Possible values: follow, tip, host, cheer, redemption, raid, superchat, sponsor, merch
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channel(after: number, before: number, limit: number, mincheer: number, minhost: number, minsub: number, mintip: number, origin: string, types: string, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).channel(after, before, limit, mincheer, minhost, minsub, mintip, origin, types, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get activity details by id
         * @summary /:channel/:activityId
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelActivityId(channel: string, activityId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).channelActivityId(channel, activityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update activity id
         * @summary /:channel/:activityId1
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelActivityId1(channel: string, activityId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).channelActivityId1(channel, activityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replay activity
         * @summary /:channel/:activityId/replay
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelActivityIdReplay(channel: string, activityId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success3>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).channelActivityIdReplay(channel, activityId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List channel\'s top activities by selected type
         * @summary /:channel/top
         * @param {number} offset integer - starting element
         * @param {number} limit integer - number of events
         * @param {string} type string - Possible values: cheer, tip
         * @param {string} period string - Possible values: alltime, months, weeks, session
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelTop(offset: number, limit: number, type: string, period: string, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success1>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).channelTop(offset, limit, type, period, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List channel activities
         * @summary /:channel
         * @param {number} after datetime - Start date
         * @param {number} before datetime - End date
         * @param {number} limit integer - events per page between 1 and 100
         * @param {number} mincheer integer - minimum amount of bits in cheer
         * @param {number} minhost integer - minimum amount of viewers in host
         * @param {number} minsub integer - minimum amount of subscription\&#39;s months
         * @param {number} mintip integer - minimum amount of tip
         * @param {string} origin 
         * @param {string} types array - Possible values: follow, tip, host, cheer, redemption, raid, superchat, sponsor, merch
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel(after: number, before: number, limit: number, mincheer: number, minhost: number, minsub: number, mintip: number, origin: string, types: string, channel: string, options?: any): AxiosPromise<Array<Success>> {
            return ActivitiesApiFp(configuration).channel(after, before, limit, mincheer, minhost, minsub, mintip, origin, types, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get activity details by id
         * @summary /:channel/:activityId
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActivityId(channel: string, activityId: string, options?: any): AxiosPromise<Success> {
            return ActivitiesApiFp(configuration).channelActivityId(channel, activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update activity id
         * @summary /:channel/:activityId1
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActivityId1(channel: string, activityId: string, options?: any): AxiosPromise<void> {
            return ActivitiesApiFp(configuration).channelActivityId1(channel, activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replay activity
         * @summary /:channel/:activityId/replay
         * @param {string} channel guid - Channel id
         * @param {string} activityId guid - Activity id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActivityIdReplay(channel: string, activityId: string, options?: any): AxiosPromise<Success3> {
            return ActivitiesApiFp(configuration).channelActivityIdReplay(channel, activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * List channel\'s top activities by selected type
         * @summary /:channel/top
         * @param {number} offset integer - starting element
         * @param {number} limit integer - number of events
         * @param {string} type string - Possible values: cheer, tip
         * @param {string} period string - Possible values: alltime, months, weeks, session
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTop(offset: number, limit: number, type: string, period: string, channel: string, options?: any): AxiosPromise<Array<Success1>> {
            return ActivitiesApiFp(configuration).channelTop(offset, limit, type, period, channel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * List channel activities
     * @summary /:channel
     * @param {number} after datetime - Start date
     * @param {number} before datetime - End date
     * @param {number} limit integer - events per page between 1 and 100
     * @param {number} mincheer integer - minimum amount of bits in cheer
     * @param {number} minhost integer - minimum amount of viewers in host
     * @param {number} minsub integer - minimum amount of subscription\&#39;s months
     * @param {number} mintip integer - minimum amount of tip
     * @param {string} origin 
     * @param {string} types array - Possible values: follow, tip, host, cheer, redemption, raid, superchat, sponsor, merch
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public channel(after: number, before: number, limit: number, mincheer: number, minhost: number, minsub: number, mintip: number, origin: string, types: string, channel: string, options?: any) {
        return ActivitiesApiFp(this.configuration).channel(after, before, limit, mincheer, minhost, minsub, mintip, origin, types, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get activity details by id
     * @summary /:channel/:activityId
     * @param {string} channel guid - Channel id
     * @param {string} activityId guid - Activity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public channelActivityId(channel: string, activityId: string, options?: any) {
        return ActivitiesApiFp(this.configuration).channelActivityId(channel, activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update activity id
     * @summary /:channel/:activityId1
     * @param {string} channel guid - Channel id
     * @param {string} activityId guid - Activity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public channelActivityId1(channel: string, activityId: string, options?: any) {
        return ActivitiesApiFp(this.configuration).channelActivityId1(channel, activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replay activity
     * @summary /:channel/:activityId/replay
     * @param {string} channel guid - Channel id
     * @param {string} activityId guid - Activity id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public channelActivityIdReplay(channel: string, activityId: string, options?: any) {
        return ActivitiesApiFp(this.configuration).channelActivityIdReplay(channel, activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List channel\'s top activities by selected type
     * @summary /:channel/top
     * @param {number} offset integer - starting element
     * @param {number} limit integer - number of events
     * @param {string} type string - Possible values: cheer, tip
     * @param {string} period string - Possible values: alltime, months, weeks, session
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public channelTop(offset: number, limit: number, type: string, period: string, channel: string, options?: any) {
        return ActivitiesApiFp(this.configuration).channelTop(offset, limit, type, period, channel, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BotApi - axios parameter creator
 * @export
 */
export const BotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of bot modules
         * @summary /:channel/counters/:counter
         * @param {string} channel guid - Channel id
         * @param {string} counter string - Counter name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelCountersCounter: async (channel: string, counter: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelCountersCounter.');
            }
            // verify required parameter 'counter' is not null or undefined
            if (counter === null || counter === undefined) {
                throw new RequiredError('counter','Required parameter counter was null or undefined when calling channelCountersCounter.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelCountersCounter.');
            }
            const localVarPath = `/bot/{channel}/counters/{counter}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"counter"}}`, encodeURIComponent(String(counter)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists default commands
         * @summary /:channel/default
         * @param {string} language string - language iso code lowercase (eg. en)
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault: async (language: string, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling channelDefault.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelDefault.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelDefault.');
            }
            const localVarPath = `/bot/commands/{channel}/default`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Join bot to channel
         * @summary /:channel/join
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelJoin: async (channel: string, accept: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelJoin.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelJoin.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelJoin.');
            }
            const localVarPath = `/bot/{channel}/join`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set bot language
         * @summary /:channel/language
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1languagerequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLanguage: async (channel: string, accept: string, body: Model13Achannel1languagerequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelLanguage.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelLanguage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelLanguage.');
            }
            const localVarPath = `/bot/{channel}/language`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List channel permissions for users
         * @summary /:channel/levels
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLevels: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelLevels.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelLevels.');
            }
            const localVarPath = `/bot/{channel}/levels`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove user from permission table
         * @summary /:channel/levels/:username
         * @param {string} channel guid - Channel id
         * @param {string} username string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLevelsUsername: async (channel: string, username: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelLevelsUsername.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling channelLevelsUsername.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelLevelsUsername.');
            }
            const localVarPath = `/bot/{channel}/levels/{username}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mute bot
         * @summary /:channel/mute
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelMute: async (channel: string, accept: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelMute.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelMute.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelMute.');
            }
            const localVarPath = `/bot/{channel}/mute`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Leave bot from channel
         * @summary /:channel/part
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPart: async (channel: string, accept: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPart.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelPart.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelPart.');
            }
            const localVarPath = `/bot/{channel}/part`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List channel\'s public commands
         * @summary /:channel/public
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPublic: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPublic.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelPublic.');
            }
            const localVarPath = `/bot/commands/{channel}/public`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send message to channel as bot
         * @summary /:channel/say
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1sayrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSay: async (channel: string, accept: string, body: Model13Achannel1sayrequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelSay.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelSay.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelSay.');
            }
            const localVarPath = `/bot/{channel}/say`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unmute bot
         * @summary /:channel/unmute
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUnmute: async (channel: string, accept: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUnmute.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUnmute.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelUnmute.');
            }
            const localVarPath = `/bot/{channel}/unmute`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List custom commands
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel.');
            }
            const localVarPath = `/bot/commands/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get bot info
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1234: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel1234.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel1234.');
            }
            const localVarPath = `/bot/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add user to permissions table
         * @summary /:channel/levels
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1levelsrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelLevels: async (channel: string, accept: string, body: Model13Achannel1levelsrequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannelLevels.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannelLevels.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannelLevels.');
            }
            const localVarPath = `/bot/{channel}/levels`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotApi - functional programming interface
 * @export
 */
export const BotApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get list of bot modules
         * @summary /:channel/counters/:counter
         * @param {string} channel guid - Channel id
         * @param {string} counter string - Counter name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelCountersCounter(channel: string, counter: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success27>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelCountersCounter(channel, counter, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists default commands
         * @summary /:channel/default
         * @param {string} language string - language iso code lowercase (eg. en)
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDefault(language: string, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success6>>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelDefault(language, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Join bot to channel
         * @summary /:channel/join
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelJoin(channel: string, accept: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotJoinResponse>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelJoin(channel, accept, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set bot language
         * @summary /:channel/language
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1languagerequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelLanguage(channel: string, accept: string, body: Model13Achannel1languagerequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelLanguage(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List channel permissions for users
         * @summary /:channel/levels
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelLevels(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserLevel>>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelLevels(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove user from permission table
         * @summary /:channel/levels/:username
         * @param {string} channel guid - Channel id
         * @param {string} username string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelLevelsUsername(channel: string, username: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success26>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelLevelsUsername(channel, username, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Mute bot
         * @summary /:channel/mute
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelMute(channel: string, accept: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotJoinResponse>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelMute(channel, accept, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Leave bot from channel
         * @summary /:channel/part
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPart(channel: string, accept: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotJoinResponse>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelPart(channel, accept, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List channel\'s public commands
         * @summary /:channel/public
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPublic(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotCommand>>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelPublic(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send message to channel as bot
         * @summary /:channel/say
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1sayrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelSay(channel: string, accept: string, body: Model13Achannel1sayrequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotJoinResponse>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelSay(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unmute bot
         * @summary /:channel/unmute
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUnmute(channel: string, accept: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotJoinResponse>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).channelUnmute(channel, accept, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List custom commands
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotCommand>>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).getChannel(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get bot info
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel1234(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotSettings>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).getChannel1234(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add user to permissions table
         * @summary /:channel/levels
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1levelsrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannelLevels(channel: string, accept: string, body: Model13Achannel1levelsrequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLevel>> {
            const localVarAxiosArgs = await BotApiAxiosParamCreator(configuration).postChannelLevels(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BotApi - factory interface
 * @export
 */
export const BotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get list of bot modules
         * @summary /:channel/counters/:counter
         * @param {string} channel guid - Channel id
         * @param {string} counter string - Counter name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelCountersCounter(channel: string, counter: string, accept: string, options?: any): AxiosPromise<Success27> {
            return BotApiFp(configuration).channelCountersCounter(channel, counter, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists default commands
         * @summary /:channel/default
         * @param {string} language string - language iso code lowercase (eg. en)
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault(language: string, channel: string, accept: string, options?: any): AxiosPromise<Array<Success6>> {
            return BotApiFp(configuration).channelDefault(language, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Join bot to channel
         * @summary /:channel/join
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelJoin(channel: string, accept: string, contentType: string, options?: any): AxiosPromise<BotJoinResponse> {
            return BotApiFp(configuration).channelJoin(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Set bot language
         * @summary /:channel/language
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1languagerequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLanguage(channel: string, accept: string, body: Model13Achannel1languagerequest, options?: any): AxiosPromise<string> {
            return BotApiFp(configuration).channelLanguage(channel, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List channel permissions for users
         * @summary /:channel/levels
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLevels(channel: string, accept: string, options?: any): AxiosPromise<Array<UserLevel>> {
            return BotApiFp(configuration).channelLevels(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove user from permission table
         * @summary /:channel/levels/:username
         * @param {string} channel guid - Channel id
         * @param {string} username string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLevelsUsername(channel: string, username: string, accept: string, options?: any): AxiosPromise<Success26> {
            return BotApiFp(configuration).channelLevelsUsername(channel, username, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Mute bot
         * @summary /:channel/mute
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelMute(channel: string, accept: string, contentType: string, options?: any): AxiosPromise<BotJoinResponse> {
            return BotApiFp(configuration).channelMute(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Leave bot from channel
         * @summary /:channel/part
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPart(channel: string, accept: string, contentType: string, options?: any): AxiosPromise<BotJoinResponse> {
            return BotApiFp(configuration).channelPart(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * List channel\'s public commands
         * @summary /:channel/public
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPublic(channel: string, accept: string, options?: any): AxiosPromise<Array<BotCommand>> {
            return BotApiFp(configuration).channelPublic(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Send message to channel as bot
         * @summary /:channel/say
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1sayrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSay(channel: string, accept: string, body: Model13Achannel1sayrequest, options?: any): AxiosPromise<BotJoinResponse> {
            return BotApiFp(configuration).channelSay(channel, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Unmute bot
         * @summary /:channel/unmute
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUnmute(channel: string, accept: string, contentType: string, options?: any): AxiosPromise<BotJoinResponse> {
            return BotApiFp(configuration).channelUnmute(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * List custom commands
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channel: string, accept: string, options?: any): AxiosPromise<Array<BotCommand>> {
            return BotApiFp(configuration).getChannel(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get bot info
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1234(channel: string, accept: string, options?: any): AxiosPromise<BotSettings> {
            return BotApiFp(configuration).getChannel1234(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Add user to permissions table
         * @summary /:channel/levels
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannel1levelsrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelLevels(channel: string, accept: string, body: Model13Achannel1levelsrequest, options?: any): AxiosPromise<UserLevel> {
            return BotApiFp(configuration).postChannelLevels(channel, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotApi - object-oriented interface
 * @export
 * @class BotApi
 * @extends {BaseAPI}
 */
export class BotApi extends BaseAPI {
    /**
     * Get list of bot modules
     * @summary /:channel/counters/:counter
     * @param {string} channel guid - Channel id
     * @param {string} counter string - Counter name
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelCountersCounter(channel: string, counter: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).channelCountersCounter(channel, counter, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists default commands
     * @summary /:channel/default
     * @param {string} language string - language iso code lowercase (eg. en)
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelDefault(language: string, channel: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).channelDefault(language, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Join bot to channel
     * @summary /:channel/join
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelJoin(channel: string, accept: string, contentType: string, options?: any) {
        return BotApiFp(this.configuration).channelJoin(channel, accept, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set bot language
     * @summary /:channel/language
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {Model13Achannel1languagerequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelLanguage(channel: string, accept: string, body: Model13Achannel1languagerequest, options?: any) {
        return BotApiFp(this.configuration).channelLanguage(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List channel permissions for users
     * @summary /:channel/levels
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelLevels(channel: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).channelLevels(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove user from permission table
     * @summary /:channel/levels/:username
     * @param {string} channel guid - Channel id
     * @param {string} username string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelLevelsUsername(channel: string, username: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).channelLevelsUsername(channel, username, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mute bot
     * @summary /:channel/mute
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelMute(channel: string, accept: string, contentType: string, options?: any) {
        return BotApiFp(this.configuration).channelMute(channel, accept, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Leave bot from channel
     * @summary /:channel/part
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelPart(channel: string, accept: string, contentType: string, options?: any) {
        return BotApiFp(this.configuration).channelPart(channel, accept, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List channel\'s public commands
     * @summary /:channel/public
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelPublic(channel: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).channelPublic(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send message to channel as bot
     * @summary /:channel/say
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {Model13Achannel1sayrequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelSay(channel: string, accept: string, body: Model13Achannel1sayrequest, options?: any) {
        return BotApiFp(this.configuration).channelSay(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unmute bot
     * @summary /:channel/unmute
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public channelUnmute(channel: string, accept: string, contentType: string, options?: any) {
        return BotApiFp(this.configuration).channelUnmute(channel, accept, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List custom commands
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public getChannel(channel: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).getChannel(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get bot info
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public getChannel1234(channel: string, accept: string, options?: any) {
        return BotApiFp(this.configuration).getChannel1234(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add user to permissions table
     * @summary /:channel/levels
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {Model13Achannel1levelsrequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotApi
     */
    public postChannelLevels(channel: string, accept: string, body: Model13Achannel1levelsrequest, options?: any) {
        return BotApiFp(this.configuration).postChannelLevels(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get channel details
         * @summary /:channel/details
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDetails: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelDetails.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelDetails.');
            }
            const localVarPath = `/channels/{channel}/details`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get emotes that can be used on channel (twitch, bttv, ffz)
         * @summary /:channel/emotes
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelEmotes: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelEmotes.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelEmotes.');
            }
            const localVarPath = `/channels/{channel}/emotes`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /:channelId/accesstoken
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelIdAccesstoken: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelIdAccesstoken.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelIdAccesstoken.');
            }
            const localVarPath = `/channels/{channel}/accesstoken`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /:channel/socket
         * @param {string} channel guid - Channel id
         * @param {string} contentType 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSocket: async (channel: string, contentType: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelSocket.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelSocket.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelSocket.');
            }
            const localVarPath = `/channels/{channel}/socket`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get channel details for provided channel id or channel name
         * @summary /:channel
         * @param {string} channel String|guid - Channel name or channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12345: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel12345.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel12345.');
            }
            const localVarPath = `/channels/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get channels details linked to provided JWT Token
         * @summary /me
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me: async (accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling me.');
            }
            const localVarPath = `/channels/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get channel details
         * @summary /:channel/details
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDetails(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelDetails>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelDetails(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get emotes that can be used on channel (twitch, bttv, ffz)
         * @summary /:channel/emotes
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelEmotes(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelEmotes>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelEmotes(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /:channelId/accesstoken
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelIdAccesstoken(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelIdAccesstoken(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /:channel/socket
         * @param {string} channel guid - Channel id
         * @param {string} contentType 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelSocket(channel: string, contentType: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).channelSocket(channel, contentType, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get channel details for provided channel id or channel name
         * @summary /:channel
         * @param {string} channel String|guid - Channel name or channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel12345(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleChannelDetails>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannel12345(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get channels details linked to provided JWT Token
         * @summary /me
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async me(accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkedChannels>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).me(accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get channel details
         * @summary /:channel/details
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDetails(channel: string, accept: string, options?: any): AxiosPromise<ChannelDetails> {
            return ChannelsApiFp(configuration).channelDetails(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get emotes that can be used on channel (twitch, bttv, ffz)
         * @summary /:channel/emotes
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelEmotes(channel: string, accept: string, options?: any): AxiosPromise<ChannelEmotes> {
            return ChannelsApiFp(configuration).channelEmotes(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /:channelId/accesstoken
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelIdAccesstoken(channel: string, accept: string, options?: any): AxiosPromise<void> {
            return ChannelsApiFp(configuration).channelIdAccesstoken(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /:channel/socket
         * @param {string} channel guid - Channel id
         * @param {string} contentType 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSocket(channel: string, contentType: string, accept: string, options?: any): AxiosPromise<void> {
            return ChannelsApiFp(configuration).channelSocket(channel, contentType, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get channel details for provided channel id or channel name
         * @summary /:channel
         * @param {string} channel String|guid - Channel name or channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12345(channel: string, accept: string, options?: any): AxiosPromise<SimpleChannelDetails> {
            return ChannelsApiFp(configuration).getChannel12345(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get channels details linked to provided JWT Token
         * @summary /me
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(accept: string, options?: any): AxiosPromise<LinkedChannels> {
            return ChannelsApiFp(configuration).me(accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * Get channel details
     * @summary /:channel/details
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public channelDetails(channel: string, accept: string, options?: any) {
        return ChannelsApiFp(this.configuration).channelDetails(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get emotes that can be used on channel (twitch, bttv, ffz)
     * @summary /:channel/emotes
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public channelEmotes(channel: string, accept: string, options?: any) {
        return ChannelsApiFp(this.configuration).channelEmotes(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /:channelId/accesstoken
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public channelIdAccesstoken(channel: string, accept: string, options?: any) {
        return ChannelsApiFp(this.configuration).channelIdAccesstoken(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /:channel/socket
     * @param {string} channel guid - Channel id
     * @param {string} contentType 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public channelSocket(channel: string, contentType: string, accept: string, options?: any) {
        return ChannelsApiFp(this.configuration).channelSocket(channel, contentType, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get channel details for provided channel id or channel name
     * @summary /:channel
     * @param {string} channel String|guid - Channel name or channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannel12345(channel: string, accept: string, options?: any) {
        return ChannelsApiFp(this.configuration).getChannel12345(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get channels details linked to provided JWT Token
     * @summary /me
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public me(accept: string, options?: any) {
        return ChannelsApiFp(this.configuration).me(accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ChatstatsApi - axios parameter creator
 * @export
 */
export const ChatstatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get global chatstats
         * @summary /
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        : async (limit: number, offset: number, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling .');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling .');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling .');
            }
            const localVarPath = `/chatstats`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for channel by channel name
         * @summary /search
         * @param {string} channel string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling search.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling search.');
            }
            const localVarPath = `/chatstats/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stats for channel name
         * @summary /:username
         * @param {string} username string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        username: async (username: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling username.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling username.');
            }
            const localVarPath = `/chatstats/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get channels details linked to provided URL
         * @summary /:username/:category/:item
         * @param {string} username 
         * @param {string} category 
         * @param {string} item 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameCategoryItem: async (username: string, category: string, item: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling usernameCategoryItem.');
            }
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new RequiredError('category','Required parameter category was null or undefined when calling usernameCategoryItem.');
            }
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling usernameCategoryItem.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling usernameCategoryItem.');
            }
            const localVarPath = `/chatstats/{username}/{category}/{item}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"category"}}`, encodeURIComponent(String(category)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get channel\'s \"emotes per minute\"
         * @summary /:username/epm
         * @param {number} limit integer - number of items to be shown
         * @param {string} username 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameEpm: async (limit: number, username: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usernameEpm.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling usernameEpm.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling usernameEpm.');
            }
            const localVarPath = `/chatstats/{username}/epm`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get channels stats
         * @summary /:username/stats
         * @param {number} limit integer - Number of items to be shown
         * @param {string} username string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameStats: async (limit: number, username: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling usernameStats.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling usernameStats.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling usernameStats.');
            }
            const localVarPath = `/chatstats/{username}/stats`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatstatsApi - functional programming interface
 * @export
 */
export const ChatstatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get global chatstats
         * @summary /
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async (limit: number, offset: number, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChatstatsApiAxiosParamCreator(configuration).(limit, offset, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search for channel by channel name
         * @summary /search
         * @param {string} channel string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChatstatsApiAxiosParamCreator(configuration).search(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get stats for channel name
         * @summary /:username
         * @param {string} username string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async username(username: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChatstatsApiAxiosParamCreator(configuration).username(username, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get channels details linked to provided URL
         * @summary /:username/:category/:item
         * @param {string} username 
         * @param {string} category 
         * @param {string} item 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usernameCategoryItem(username: string, category: string, item: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChatstatsApiAxiosParamCreator(configuration).usernameCategoryItem(username, category, item, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get channel\'s \"emotes per minute\"
         * @summary /:username/epm
         * @param {number} limit integer - number of items to be shown
         * @param {string} username 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usernameEpm(limit: number, username: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChatstatsApiAxiosParamCreator(configuration).usernameEpm(limit, username, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get channels stats
         * @summary /:username/stats
         * @param {number} limit integer - Number of items to be shown
         * @param {string} username string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usernameStats(limit: number, username: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChatstatsApiAxiosParamCreator(configuration).usernameStats(limit, username, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChatstatsApi - factory interface
 * @export
 */
export const ChatstatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get global chatstats
         * @summary /
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        (limit: number, offset: number, accept: string, options?: any): AxiosPromise<void> {
            return ChatstatsApiFp(configuration).(limit, offset, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for channel by channel name
         * @summary /search
         * @param {string} channel string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(channel: string, accept: string, options?: any): AxiosPromise<void> {
            return ChatstatsApiFp(configuration).search(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stats for channel name
         * @summary /:username
         * @param {string} username string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        username(username: string, accept: string, options?: any): AxiosPromise<void> {
            return ChatstatsApiFp(configuration).username(username, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get channels details linked to provided URL
         * @summary /:username/:category/:item
         * @param {string} username 
         * @param {string} category 
         * @param {string} item 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameCategoryItem(username: string, category: string, item: string, accept: string, options?: any): AxiosPromise<void> {
            return ChatstatsApiFp(configuration).usernameCategoryItem(username, category, item, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get channel\'s \"emotes per minute\"
         * @summary /:username/epm
         * @param {number} limit integer - number of items to be shown
         * @param {string} username 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameEpm(limit: number, username: string, accept: string, options?: any): AxiosPromise<void> {
            return ChatstatsApiFp(configuration).usernameEpm(limit, username, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get channels stats
         * @summary /:username/stats
         * @param {number} limit integer - Number of items to be shown
         * @param {string} username string - Channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usernameStats(limit: number, username: string, accept: string, options?: any): AxiosPromise<void> {
            return ChatstatsApiFp(configuration).usernameStats(limit, username, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatstatsApi - object-oriented interface
 * @export
 * @class ChatstatsApi
 * @extends {BaseAPI}
 */
export class ChatstatsApi extends BaseAPI {
    /**
     * Get global chatstats
     * @summary /
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatstatsApi
     */
    public (limit: number, offset: number, accept: string, options?: any) {
        return ChatstatsApiFp(this.configuration).(limit, offset, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for channel by channel name
     * @summary /search
     * @param {string} channel string - Channel name
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatstatsApi
     */
    public search(channel: string, accept: string, options?: any) {
        return ChatstatsApiFp(this.configuration).search(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stats for channel name
     * @summary /:username
     * @param {string} username string - Channel name
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatstatsApi
     */
    public username(username: string, accept: string, options?: any) {
        return ChatstatsApiFp(this.configuration).username(username, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get channels details linked to provided URL
     * @summary /:username/:category/:item
     * @param {string} username 
     * @param {string} category 
     * @param {string} item 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatstatsApi
     */
    public usernameCategoryItem(username: string, category: string, item: string, accept: string, options?: any) {
        return ChatstatsApiFp(this.configuration).usernameCategoryItem(username, category, item, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get channel\'s \"emotes per minute\"
     * @summary /:username/epm
     * @param {number} limit integer - number of items to be shown
     * @param {string} username 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatstatsApi
     */
    public usernameEpm(limit: number, username: string, accept: string, options?: any) {
        return ChatstatsApiFp(this.configuration).usernameEpm(limit, username, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get channels stats
     * @summary /:username/stats
     * @param {number} limit integer - Number of items to be shown
     * @param {string} username string - Channel name
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatstatsApi
     */
    public usernameStats(limit: number, username: string, accept: string, options?: any) {
        return ChatstatsApiFp(this.configuration).usernameStats(limit, username, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get command details
         * @summary /:channel/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelCommandId: async (channel: string, commandId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelCommandId.');
            }
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling channelCommandId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelCommandId.');
            }
            const localVarPath = `/bot/commands/{channel}/{commandId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete command
         * @summary /:channel/:commandId1
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelCommandId1: async (channel: string, commandId: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelCommandId1.');
            }
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling channelCommandId1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelCommandId1.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelCommandId1.');
            }
            const localVarPath = `/bot/commands/{channel}/{commandId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists default commands
         * @summary /:channel/default
         * @param {string} language string - language iso code lowercase (eg. en)
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault: async (language: string, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling channelDefault.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelDefault.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelDefault.');
            }
            const localVarPath = `/bot/commands/{channel}/default`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update default command
         * @summary /:channel/default/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId string - command id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefaultCommandId: async (channel: string, commandId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelDefaultCommandId.');
            }
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling channelDefaultCommandId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelDefaultCommandId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelDefaultCommandId.');
            }
            const localVarPath = `/bot/commands/{channel}/default/{commandId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List channel\'s public commands
         * @summary /:channel/public
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPublic: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPublic.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelPublic.');
            }
            const localVarPath = `/bot/commands/{channel}/public`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List custom commands
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel.');
            }
            const localVarPath = `/bot/commands/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new command
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannelrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel: async (channel: string, accept: string, body: Model13Achannelrequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannel.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannel.');
            }
            const localVarPath = `/bot/commands/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update command details
         * @summary /:channel/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {Command} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelCommandId: async (channel: string, commandId: string, accept: string, command: Command, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannelCommandId.');
            }
            // verify required parameter 'commandId' is not null or undefined
            if (commandId === null || commandId === undefined) {
                throw new RequiredError('commandId','Required parameter commandId was null or undefined when calling putChannelCommandId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling putChannelCommandId.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling putChannelCommandId.');
            }
            const localVarPath = `/bot/commands/{channel}/{commandId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"commandId"}}`, encodeURIComponent(String(commandId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof command !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(command !== undefined ? command : {}) : (command || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get command details
         * @summary /:channel/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelCommandId(channel: string, commandId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotCommand>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).channelCommandId(channel, commandId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete command
         * @summary /:channel/:commandId1
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelCommandId1(channel: string, commandId: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).channelCommandId1(channel, commandId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists default commands
         * @summary /:channel/default
         * @param {string} language string - language iso code lowercase (eg. en)
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDefault(language: string, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success6>>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).channelDefault(language, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update default command
         * @summary /:channel/default/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId string - command id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDefaultCommandId(channel: string, commandId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotCommand>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).channelDefaultCommandId(channel, commandId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List channel\'s public commands
         * @summary /:channel/public
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPublic(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotCommand>>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).channelPublic(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List custom commands
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotCommand>>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).getChannel(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new command
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannelrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannel(channel: string, accept: string, body: Model13Achannelrequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotCommand>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).postChannel(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update command details
         * @summary /:channel/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {Command} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelCommandId(channel: string, commandId: string, accept: string, command: Command, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotCommand>> {
            const localVarAxiosArgs = await CommandsApiAxiosParamCreator(configuration).putChannelCommandId(channel, commandId, accept, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get command details
         * @summary /:channel/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelCommandId(channel: string, commandId: string, accept: string, options?: any): AxiosPromise<BotCommand> {
            return CommandsApiFp(configuration).channelCommandId(channel, commandId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete command
         * @summary /:channel/:commandId1
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelCommandId1(channel: string, commandId: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return CommandsApiFp(configuration).channelCommandId1(channel, commandId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists default commands
         * @summary /:channel/default
         * @param {string} language string - language iso code lowercase (eg. en)
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault(language: string, channel: string, accept: string, options?: any): AxiosPromise<Array<Success6>> {
            return CommandsApiFp(configuration).channelDefault(language, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update default command
         * @summary /:channel/default/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId string - command id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefaultCommandId(channel: string, commandId: string, accept: string, body: object, options?: any): AxiosPromise<BotCommand> {
            return CommandsApiFp(configuration).channelDefaultCommandId(channel, commandId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List channel\'s public commands
         * @summary /:channel/public
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPublic(channel: string, accept: string, options?: any): AxiosPromise<Array<BotCommand>> {
            return CommandsApiFp(configuration).channelPublic(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List custom commands
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channel: string, accept: string, options?: any): AxiosPromise<Array<BotCommand>> {
            return CommandsApiFp(configuration).getChannel(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new command
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannelrequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel(channel: string, accept: string, body: Model13Achannelrequest, options?: any): AxiosPromise<BotCommand> {
            return CommandsApiFp(configuration).postChannel(channel, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update command details
         * @summary /:channel/:commandId
         * @param {string} channel guid - Channel id
         * @param {string} commandId guid - Command id
         * @param {string} accept 
         * @param {Command} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelCommandId(channel: string, commandId: string, accept: string, command: Command, options?: any): AxiosPromise<BotCommand> {
            return CommandsApiFp(configuration).putChannelCommandId(channel, commandId, accept, command, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     * Get command details
     * @summary /:channel/:commandId
     * @param {string} channel guid - Channel id
     * @param {string} commandId guid - Command id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public channelCommandId(channel: string, commandId: string, accept: string, options?: any) {
        return CommandsApiFp(this.configuration).channelCommandId(channel, commandId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete command
     * @summary /:channel/:commandId1
     * @param {string} channel guid - Channel id
     * @param {string} commandId guid - Command id
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public channelCommandId1(channel: string, commandId: string, accept: string, body: string, options?: any) {
        return CommandsApiFp(this.configuration).channelCommandId1(channel, commandId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists default commands
     * @summary /:channel/default
     * @param {string} language string - language iso code lowercase (eg. en)
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public channelDefault(language: string, channel: string, accept: string, options?: any) {
        return CommandsApiFp(this.configuration).channelDefault(language, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update default command
     * @summary /:channel/default/:commandId
     * @param {string} channel guid - Channel id
     * @param {string} commandId string - command id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public channelDefaultCommandId(channel: string, commandId: string, accept: string, body: object, options?: any) {
        return CommandsApiFp(this.configuration).channelDefaultCommandId(channel, commandId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List channel\'s public commands
     * @summary /:channel/public
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public channelPublic(channel: string, accept: string, options?: any) {
        return CommandsApiFp(this.configuration).channelPublic(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List custom commands
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public getChannel(channel: string, accept: string, options?: any) {
        return CommandsApiFp(this.configuration).getChannel(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new command
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {Model13Achannelrequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public postChannel(channel: string, accept: string, body: Model13Achannelrequest, options?: any) {
        return CommandsApiFp(this.configuration).postChannel(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update command details
     * @summary /:channel/:commandId
     * @param {string} channel guid - Channel id
     * @param {string} commandId guid - Command id
     * @param {string} accept 
     * @param {Command} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public putChannelCommandId(channel: string, commandId: string, accept: string, command: Command, options?: any) {
        return CommandsApiFp(this.configuration).putChannelCommandId(channel, commandId, accept, command, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ContestsApi - axios parameter creator
 * @export
 */
export const ContestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List contests
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestId: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestId.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestId.');
            }
            const localVarPath = `/contests/{channel}/{contestId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close contest
         * @summary /:channel/:contestId/close
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdClose: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdClose.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdClose.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdClose.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/close`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund users participating in contest
         * @summary /:channel/:contestId/refund
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdRefund: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdRefund.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdRefund.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdRefund.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/refund`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a contest
         * @summary /:channel/:contestId/start
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdStart: async (channel: string, contestId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdStart.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdStart.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdStart.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelContestIdStart.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/start`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Draw a winner of contest
         * @summary /:channel/:contestId/winner
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdWinner: async (channel: string, contestId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdWinner.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdWinner.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdWinner.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelContestIdWinner.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/winner`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List previous contests
         * @summary /:channel/history
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelHistory: async (limit: number, offset: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelHistory.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelHistory.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelHistory.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelHistory.');
            }
            const localVarPath = `/contests/{channel}/history`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List contests
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123456: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel123456.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel123456.');
            }
            const localVarPath = `/contests/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests bets
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel Id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelContestIdBet: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelContestIdBet.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling getChannelContestIdBet.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannelContestIdBet.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/bet`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new contest
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel12: async (channel: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannel12.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannel12.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannel12.');
            }
            const localVarPath = `/contests/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContestsApi - functional programming interface
 * @export
 */
export const ContestsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List contests
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestId(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contest>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).channelContestId(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Close contest
         * @summary /:channel/:contestId/close
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdClose(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).channelContestIdClose(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Refund users participating in contest
         * @summary /:channel/:contestId/refund
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdRefund(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).channelContestIdRefund(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a contest
         * @summary /:channel/:contestId/start
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdStart(channel: string, contestId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contest>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).channelContestIdStart(channel, contestId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Draw a winner of contest
         * @summary /:channel/:contestId/winner
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdWinner(channel: string, contestId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).channelContestIdWinner(channel, contestId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List previous contests
         * @summary /:channel/history
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelHistory(limit: number, offset: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).channelHistory(limit, offset, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List contests
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel123456(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contests>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).getChannel123456(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get contests bets
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel Id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelContestIdBet(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).getChannelContestIdBet(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new contest
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannel12(channel: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contests>> {
            const localVarAxiosArgs = await ContestsApiAxiosParamCreator(configuration).postChannel12(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContestsApi - factory interface
 * @export
 */
export const ContestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List contests
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestId(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<Contest> {
            return ContestsApiFp(configuration).channelContestId(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Close contest
         * @summary /:channel/:contestId/close
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdClose(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<string> {
            return ContestsApiFp(configuration).channelContestIdClose(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund users participating in contest
         * @summary /:channel/:contestId/refund
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdRefund(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<void> {
            return ContestsApiFp(configuration).channelContestIdRefund(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a contest
         * @summary /:channel/:contestId/start
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdStart(channel: string, contestId: string, accept: string, body: object, options?: any): AxiosPromise<Contest> {
            return ContestsApiFp(configuration).channelContestIdStart(channel, contestId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Draw a winner of contest
         * @summary /:channel/:contestId/winner
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdWinner(channel: string, contestId: string, accept: string, body: object, options?: any): AxiosPromise<string> {
            return ContestsApiFp(configuration).channelContestIdWinner(channel, contestId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List previous contests
         * @summary /:channel/history
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelHistory(limit: number, offset: number, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return ContestsApiFp(configuration).channelHistory(limit, offset, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List contests
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123456(channel: string, accept: string, options?: any): AxiosPromise<Contests> {
            return ContestsApiFp(configuration).getChannel123456(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests bets
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel Id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelContestIdBet(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<void> {
            return ContestsApiFp(configuration).getChannelContestIdBet(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new contest
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel12(channel: string, accept: string, body: object, options?: any): AxiosPromise<Contests> {
            return ContestsApiFp(configuration).postChannel12(channel, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContestsApi - object-oriented interface
 * @export
 * @class ContestsApi
 * @extends {BaseAPI}
 */
export class ContestsApi extends BaseAPI {
    /**
     * List contests
     * @summary /:channel/:contestId
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public channelContestId(channel: string, contestId: string, accept: string, options?: any) {
        return ContestsApiFp(this.configuration).channelContestId(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close contest
     * @summary /:channel/:contestId/close
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public channelContestIdClose(channel: string, contestId: string, accept: string, options?: any) {
        return ContestsApiFp(this.configuration).channelContestIdClose(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund users participating in contest
     * @summary /:channel/:contestId/refund
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public channelContestIdRefund(channel: string, contestId: string, accept: string, options?: any) {
        return ContestsApiFp(this.configuration).channelContestIdRefund(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a contest
     * @summary /:channel/:contestId/start
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public channelContestIdStart(channel: string, contestId: string, accept: string, body: object, options?: any) {
        return ContestsApiFp(this.configuration).channelContestIdStart(channel, contestId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Draw a winner of contest
     * @summary /:channel/:contestId/winner
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public channelContestIdWinner(channel: string, contestId: string, accept: string, body: object, options?: any) {
        return ContestsApiFp(this.configuration).channelContestIdWinner(channel, contestId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List previous contests
     * @summary /:channel/history
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public channelHistory(limit: number, offset: number, channel: string, accept: string, options?: any) {
        return ContestsApiFp(this.configuration).channelHistory(limit, offset, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List contests
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getChannel123456(channel: string, accept: string, options?: any) {
        return ContestsApiFp(this.configuration).getChannel123456(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests bets
     * @summary /:channel/:contestId/bet
     * @param {string} channel guid - Channel Id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public getChannelContestIdBet(channel: string, contestId: string, accept: string, options?: any) {
        return ContestsApiFp(this.configuration).getChannelContestIdBet(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new contest
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestsApi
     */
    public postChannel12(channel: string, accept: string, body: object, options?: any) {
        return ContestsApiFp(this.configuration).postChannel12(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * FiltersApi - axios parameter creator
 * @export
 */
export const FiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details for provided banned phrase id
         * @summary /banphrases/search
         * @param {string} id guid - banned phrase id
         * @param {string} channel string - channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banphrasesSearch: async (id: string, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling banphrasesSearch.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling banphrasesSearch.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling banphrasesSearch.');
            }
            const localVarPath = `/bot/filters/banphrases/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new banphrases group
         * @summary /:channel/banphrases
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Banphrasesrequest} banphrasesrequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelBanphrases: async (channel: string, accept: string, banphrasesrequest: Banphrasesrequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelBanphrases.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelBanphrases.');
            }
            // verify required parameter 'banphrasesrequest' is not null or undefined
            if (banphrasesrequest === null || banphrasesrequest === undefined) {
                throw new RequiredError('banphrasesrequest','Required parameter banphrasesrequest was null or undefined when calling channelBanphrases.');
            }
            const localVarPath = `/bot/filters/{channel}/banphrases`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof banphrasesrequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(banphrasesrequest !== undefined ? banphrasesrequest : {}) : (banphrasesrequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update banphrases group
         * @summary /:channel/banphrases/:groupId
         * @param {string} channel guid - Channel id
         * @param {string} groupId guid - group id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelBanphrasesGroupId: async (channel: string, groupId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelBanphrasesGroupId.');
            }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling channelBanphrasesGroupId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelBanphrasesGroupId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelBanphrasesGroupId.');
            }
            const localVarPath = `/bot/filters/{channel}/banphrases/{groupId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a contest
         * @summary /:channel/:filter
         * @param {string} channel guid - Channel id
         * @param {string} filter 
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelFilter: async (channel: string, filter: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelFilter.');
            }
            // verify required parameter 'filter' is not null or undefined
            if (filter === null || filter === undefined) {
                throw new RequiredError('filter','Required parameter filter was null or undefined when calling channelFilter.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelFilter.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelFilter.');
            }
            const localVarPath = `/bot/filters/{channel}/{filter}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"filter"}}`, encodeURIComponent(String(filter)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test a message against filters
         * @summary /:channel/test
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTest: async (channel: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelTest.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelTest.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelTest.');
            }
            const localVarPath = `/bot/filters/{channel}/test`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete banphrases group
         * @summary /:channel/banphrases/:groupId
         * @param {string} channel guid - Channel id
         * @param {string} groupId 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelBanphrasesGroupId: async (channel: string, groupId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling deleteChannelBanphrasesGroupId.');
            }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling deleteChannelBanphrasesGroupId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling deleteChannelBanphrasesGroupId.');
            }
            const localVarPath = `/bot/filters/{channel}/banphrases/{groupId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List filters
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel123.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel123.');
            }
            const localVarPath = `/bot/filters/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update channel settings
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannel: async (channel: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannel.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling putChannel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannel.');
            }
            const localVarPath = `/bot/filters/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FiltersApi - functional programming interface
 * @export
 */
export const FiltersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get details for provided banned phrase id
         * @summary /banphrases/search
         * @param {string} id guid - banned phrase id
         * @param {string} channel string - channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banphrasesSearch(id: string, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success16>>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).banphrasesSearch(id, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add new banphrases group
         * @summary /:channel/banphrases
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Banphrasesrequest} banphrasesrequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelBanphrases(channel: string, accept: string, banphrasesrequest: Banphrasesrequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).channelBanphrases(channel, accept, banphrasesrequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update banphrases group
         * @summary /:channel/banphrases/:groupId
         * @param {string} channel guid - Channel id
         * @param {string} groupId guid - group id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelBanphrasesGroupId(channel: string, groupId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).channelBanphrasesGroupId(channel, groupId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a contest
         * @summary /:channel/:filter
         * @param {string} channel guid - Channel id
         * @param {string} filter 
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelFilter(channel: string, filter: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).channelFilter(channel, filter, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Test a message against filters
         * @summary /:channel/test
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelTest(channel: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).channelTest(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete banphrases group
         * @summary /:channel/banphrases/:groupId
         * @param {string} channel guid - Channel id
         * @param {string} groupId 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannelBanphrasesGroupId(channel: string, groupId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).deleteChannelBanphrasesGroupId(channel, groupId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List filters
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel123(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotFilters>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).getChannel123(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update channel settings
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannel(channel: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FiltersApiAxiosParamCreator(configuration).putChannel(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FiltersApi - factory interface
 * @export
 */
export const FiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get details for provided banned phrase id
         * @summary /banphrases/search
         * @param {string} id guid - banned phrase id
         * @param {string} channel string - channel name
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banphrasesSearch(id: string, channel: string, accept: string, options?: any): AxiosPromise<Array<Success16>> {
            return FiltersApiFp(configuration).banphrasesSearch(id, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Add new banphrases group
         * @summary /:channel/banphrases
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Banphrasesrequest} banphrasesrequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelBanphrases(channel: string, accept: string, banphrasesrequest: Banphrasesrequest, options?: any): AxiosPromise<void> {
            return FiltersApiFp(configuration).channelBanphrases(channel, accept, banphrasesrequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update banphrases group
         * @summary /:channel/banphrases/:groupId
         * @param {string} channel guid - Channel id
         * @param {string} groupId guid - group id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelBanphrasesGroupId(channel: string, groupId: string, accept: string, body: object, options?: any): AxiosPromise<void> {
            return FiltersApiFp(configuration).channelBanphrasesGroupId(channel, groupId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a contest
         * @summary /:channel/:filter
         * @param {string} channel guid - Channel id
         * @param {string} filter 
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelFilter(channel: string, filter: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return FiltersApiFp(configuration).channelFilter(channel, filter, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Test a message against filters
         * @summary /:channel/test
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTest(channel: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return FiltersApiFp(configuration).channelTest(channel, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete banphrases group
         * @summary /:channel/banphrases/:groupId
         * @param {string} channel guid - Channel id
         * @param {string} groupId 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelBanphrasesGroupId(channel: string, groupId: string, accept: string, options?: any): AxiosPromise<void> {
            return FiltersApiFp(configuration).deleteChannelBanphrasesGroupId(channel, groupId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List filters
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123(channel: string, accept: string, options?: any): AxiosPromise<BotFilters> {
            return FiltersApiFp(configuration).getChannel123(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update channel settings
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannel(channel: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return FiltersApiFp(configuration).putChannel(channel, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FiltersApi - object-oriented interface
 * @export
 * @class FiltersApi
 * @extends {BaseAPI}
 */
export class FiltersApi extends BaseAPI {
    /**
     * Get details for provided banned phrase id
     * @summary /banphrases/search
     * @param {string} id guid - banned phrase id
     * @param {string} channel string - channel name
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public banphrasesSearch(id: string, channel: string, accept: string, options?: any) {
        return FiltersApiFp(this.configuration).banphrasesSearch(id, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add new banphrases group
     * @summary /:channel/banphrases
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {Banphrasesrequest} banphrasesrequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public channelBanphrases(channel: string, accept: string, banphrasesrequest: Banphrasesrequest, options?: any) {
        return FiltersApiFp(this.configuration).channelBanphrases(channel, accept, banphrasesrequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update banphrases group
     * @summary /:channel/banphrases/:groupId
     * @param {string} channel guid - Channel id
     * @param {string} groupId guid - group id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public channelBanphrasesGroupId(channel: string, groupId: string, accept: string, body: object, options?: any) {
        return FiltersApiFp(this.configuration).channelBanphrasesGroupId(channel, groupId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a contest
     * @summary /:channel/:filter
     * @param {string} channel guid - Channel id
     * @param {string} filter 
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public channelFilter(channel: string, filter: string, accept: string, body: string, options?: any) {
        return FiltersApiFp(this.configuration).channelFilter(channel, filter, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a message against filters
     * @summary /:channel/test
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public channelTest(channel: string, accept: string, body: string, options?: any) {
        return FiltersApiFp(this.configuration).channelTest(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete banphrases group
     * @summary /:channel/banphrases/:groupId
     * @param {string} channel guid - Channel id
     * @param {string} groupId 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public deleteChannelBanphrasesGroupId(channel: string, groupId: string, accept: string, options?: any) {
        return FiltersApiFp(this.configuration).deleteChannelBanphrasesGroupId(channel, groupId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List filters
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public getChannel123(channel: string, accept: string, options?: any) {
        return FiltersApiFp(this.configuration).getChannel123(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update channel settings
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FiltersApi
     */
    public putChannel(channel: string, accept: string, body: string, options?: any) {
        return FiltersApiFp(this.configuration).putChannel(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GiveawaysApi - axios parameter creator
 * @export
 */
export const GiveawaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get giveaway details
         * @summary /:channel/:giveawayId
         * @param {string} entrants boolean
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayId: async (entrants: string, channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entrants' is not null or undefined
            if (entrants === null || entrants === undefined) {
                throw new RequiredError('entrants','Required parameter entrants was null or undefined when calling channelGiveawayId.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayId.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayId.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (entrants !== undefined) {
                localVarQueryParameter['entrants'] = entrants;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close current giveaway
         * @summary /:channel/:giveawayId/close
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdClose: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdClose.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdClose.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdClose.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/close`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark giveaway as complete
         * @summary /:channel/:giveawayId/complete
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdComplete: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdComplete.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdComplete.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdComplete.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/complete`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List giveaways
         * @summary /:channel/:giveawayId/joined
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdJoined: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdJoined.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdJoined.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdJoined.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/joined`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/refund
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdRefund: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdRefund.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdRefund.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdRefund.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/refund`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen giveaway
         * @summary /:channel/:giveawayId/reopen
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdReopen: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdReopen.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdReopen.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdReopen.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/reopen`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/start
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdStart: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdStart.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdStart.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdStart.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/start`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Draw a giveaway winner
         * @summary /:channel/:giveawayId/winner
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdWinner: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdWinner.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdWinner.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdWinner.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/winner`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List giveaways
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1234567: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel1234567.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel1234567.');
            }
            const localVarPath = `/giveaways/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List previous giveaways
         * @summary /:channel/history
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelHistory: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelHistory.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannelHistory.');
            }
            const localVarPath = `/giveaways/{channel}/history`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new giveaway
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel123: async (channel: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannel123.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannel123.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannel123.');
            }
            const localVarPath = `/giveaways/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiveawaysApi - functional programming interface
 * @export
 */
export const GiveawaysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get giveaway details
         * @summary /:channel/:giveawayId
         * @param {string} entrants boolean
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayId(entrants: string, channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaways>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayId(entrants, channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Close current giveaway
         * @summary /:channel/:giveawayId/close
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdClose(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdClose(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Mark giveaway as complete
         * @summary /:channel/:giveawayId/complete
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdComplete(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdComplete(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List giveaways
         * @summary /:channel/:giveawayId/joined
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdJoined(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GiveawayUserList>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdJoined(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/refund
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdRefund(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdRefund(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reopen giveaway
         * @summary /:channel/:giveawayId/reopen
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdReopen(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdReopen(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/start
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdStart(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaway>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdStart(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Draw a giveaway winner
         * @summary /:channel/:giveawayId/winner
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdWinner(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).channelGiveawayIdWinner(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List giveaways
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel1234567(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessEmpty>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).getChannel1234567(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List previous giveaways
         * @summary /:channel/history
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelHistory(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).getChannelHistory(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new giveaway
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannel123(channel: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaway>> {
            const localVarAxiosArgs = await GiveawaysApiAxiosParamCreator(configuration).postChannel123(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GiveawaysApi - factory interface
 * @export
 */
export const GiveawaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get giveaway details
         * @summary /:channel/:giveawayId
         * @param {string} entrants boolean
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayId(entrants: string, channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<Giveaways> {
            return GiveawaysApiFp(configuration).channelGiveawayId(entrants, channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Close current giveaway
         * @summary /:channel/:giveawayId/close
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdClose(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return GiveawaysApiFp(configuration).channelGiveawayIdClose(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark giveaway as complete
         * @summary /:channel/:giveawayId/complete
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdComplete(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return GiveawaysApiFp(configuration).channelGiveawayIdComplete(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List giveaways
         * @summary /:channel/:giveawayId/joined
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdJoined(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<GiveawayUserList> {
            return GiveawaysApiFp(configuration).channelGiveawayIdJoined(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/refund
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdRefund(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return GiveawaysApiFp(configuration).channelGiveawayIdRefund(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen giveaway
         * @summary /:channel/:giveawayId/reopen
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdReopen(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return GiveawaysApiFp(configuration).channelGiveawayIdReopen(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/start
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdStart(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<Giveaway> {
            return GiveawaysApiFp(configuration).channelGiveawayIdStart(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Draw a giveaway winner
         * @summary /:channel/:giveawayId/winner
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdWinner(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<void> {
            return GiveawaysApiFp(configuration).channelGiveawayIdWinner(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List giveaways
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1234567(channel: string, accept: string, options?: any): AxiosPromise<SuccessEmpty> {
            return GiveawaysApiFp(configuration).getChannel1234567(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List previous giveaways
         * @summary /:channel/history
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelHistory(channel: string, accept: string, options?: any): AxiosPromise<Array<string>> {
            return GiveawaysApiFp(configuration).getChannelHistory(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new giveaway
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel123(channel: string, accept: string, body: object, options?: any): AxiosPromise<Giveaway> {
            return GiveawaysApiFp(configuration).postChannel123(channel, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GiveawaysApi - object-oriented interface
 * @export
 * @class GiveawaysApi
 * @extends {BaseAPI}
 */
export class GiveawaysApi extends BaseAPI {
    /**
     * Get giveaway details
     * @summary /:channel/:giveawayId
     * @param {string} entrants boolean
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayId(entrants: string, channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayId(entrants, channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close current giveaway
     * @summary /:channel/:giveawayId/close
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdClose(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdClose(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark giveaway as complete
     * @summary /:channel/:giveawayId/complete
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdComplete(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdComplete(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List giveaways
     * @summary /:channel/:giveawayId/joined
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdJoined(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdJoined(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a giveaway
     * @summary /:channel/:giveawayId/refund
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdRefund(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdRefund(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen giveaway
     * @summary /:channel/:giveawayId/reopen
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdReopen(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdReopen(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a giveaway
     * @summary /:channel/:giveawayId/start
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdStart(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdStart(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Draw a giveaway winner
     * @summary /:channel/:giveawayId/winner
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public channelGiveawayIdWinner(channel: string, giveawayId: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).channelGiveawayIdWinner(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List giveaways
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public getChannel1234567(channel: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).getChannel1234567(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List previous giveaways
     * @summary /:channel/history
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public getChannelHistory(channel: string, accept: string, options?: any) {
        return GiveawaysApiFp(this.configuration).getChannelHistory(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new giveaway
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GiveawaysApi
     */
    public postChannel123(channel: string, accept: string, body: object, options?: any) {
        return GiveawaysApiFp(this.configuration).postChannel123(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LoyaltiesApi - axios parameter creator
 * @export
 */
export const LoyaltiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update loyalty settings
         * @summary /:channel1
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel1: async (channel: string, accept: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channel1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channel1.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channel1.');
            }
            const localVarPath = `/loyalty/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get loyalty settings
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12345678: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel12345678.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel12345678.');
            }
            const localVarPath = `/loyalty/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoyaltiesApi - functional programming interface
 * @export
 */
export const LoyaltiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update loyalty settings
         * @summary /:channel1
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channel1(channel: string, accept: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success40>> {
            const localVarAxiosArgs = await LoyaltiesApiAxiosParamCreator(configuration).channel1(channel, accept, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get loyalty settings
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel12345678(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success40>> {
            const localVarAxiosArgs = await LoyaltiesApiAxiosParamCreator(configuration).getChannel12345678(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoyaltiesApi - factory interface
 * @export
 */
export const LoyaltiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Update loyalty settings
         * @summary /:channel1
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channel1(channel: string, accept: string, contentType: string, options?: any): AxiosPromise<Success40> {
            return LoyaltiesApiFp(configuration).channel1(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get loyalty settings
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12345678(channel: string, accept: string, options?: any): AxiosPromise<Success40> {
            return LoyaltiesApiFp(configuration).getChannel12345678(channel, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoyaltiesApi - object-oriented interface
 * @export
 * @class LoyaltiesApi
 * @extends {BaseAPI}
 */
export class LoyaltiesApi extends BaseAPI {
    /**
     * Update loyalty settings
     * @summary /:channel1
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltiesApi
     */
    public channel1(channel: string, accept: string, contentType: string, options?: any) {
        return LoyaltiesApiFp(this.configuration).channel1(channel, accept, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get loyalty settings
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoyaltiesApi
     */
    public getChannel12345678(channel: string, accept: string, options?: any) {
        return LoyaltiesApiFp(this.configuration).getChannel12345678(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ModulesApi - axios parameter creator
 * @export
 */
export const ModulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * TODO: Add Description
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel12.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel12.');
            }
            const localVarPath = `/bot/modules/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModulesApi - functional programming interface
 * @export
 */
export const ModulesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * TODO: Add Description
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel12(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotModules>> {
            const localVarAxiosArgs = await ModulesApiAxiosParamCreator(configuration).getChannel12(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ModulesApi - factory interface
 * @export
 */
export const ModulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * TODO: Add Description
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12(channel: string, accept: string, options?: any): AxiosPromise<BotModules> {
            return ModulesApiFp(configuration).getChannel12(channel, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModulesApi - object-oriented interface
 * @export
 * @class ModulesApi
 * @extends {BaseAPI}
 */
export class ModulesApi extends BaseAPI {
    /**
     * TODO: Add Description
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModulesApi
     */
    public getChannel12(channel: string, accept: string, options?: any) {
        return ModulesApiFp(this.configuration).getChannel12(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OverlaysApi - axios parameter creator
 * @export
 */
export const OverlaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Overlay/Alerts control
         * @summary /:channel/action/:action
         * @param {string} channel guid - Channel id
         * @param {string} action string - one of reload, mute, unmute, pause, play
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActionAction: async (channel: string, action: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelActionAction.');
            }
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling channelActionAction.');
            }
            const localVarPath = `/overlays/{channel}/action/{action}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets overlay details with all widgets on it
         * @summary /:channel/:overlayId
         * @param {string} channel guid - Channel id
         * @param {string} overlayId guid - Overlay id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelOverlayId: async (channel: string, overlayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelOverlayId.');
            }
            // verify required parameter 'overlayId' is not null or undefined
            if (overlayId === null || overlayId === undefined) {
                throw new RequiredError('overlayId','Required parameter overlayId was null or undefined when calling channelOverlayId.');
            }
            const localVarPath = `/overlays/{channel}/{overlayId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"overlayId"}}`, encodeURIComponent(String(overlayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reloads overlays for channel
         * @summary /:channel/reload
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelReload: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelReload.');
            }
            const localVarPath = `/overlays/{channel}/reload`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List overlays
         * @summary /:channel
         * @param {string} search 
         * @param {string} type 
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123456789: async (search: string, type: string, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling getChannel123456789.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getChannel123456789.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel123456789.');
            }
            const localVarPath = `/overlays/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OverlaysApi - functional programming interface
 * @export
 */
export const OverlaysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Overlay/Alerts control
         * @summary /:channel/action/:action
         * @param {string} channel guid - Channel id
         * @param {string} action string - one of reload, mute, unmute, pause, play
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelActionAction(channel: string, action: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await OverlaysApiAxiosParamCreator(configuration).channelActionAction(channel, action, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets overlay details with all widgets on it
         * @summary /:channel/:overlayId
         * @param {string} channel guid - Channel id
         * @param {string} overlayId guid - Overlay id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelOverlayId(channel: string, overlayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverlayData>> {
            const localVarAxiosArgs = await OverlaysApiAxiosParamCreator(configuration).channelOverlayId(channel, overlayId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reloads overlays for channel
         * @summary /:channel/reload
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelReload(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success44>> {
            const localVarAxiosArgs = await OverlaysApiAxiosParamCreator(configuration).channelReload(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List overlays
         * @summary /:channel
         * @param {string} search 
         * @param {string} type 
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel123456789(search: string, type: string, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverlaysList>> {
            const localVarAxiosArgs = await OverlaysApiAxiosParamCreator(configuration).getChannel123456789(search, type, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OverlaysApi - factory interface
 * @export
 */
export const OverlaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Overlay/Alerts control
         * @summary /:channel/action/:action
         * @param {string} channel guid - Channel id
         * @param {string} action string - one of reload, mute, unmute, pause, play
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelActionAction(channel: string, action: string, options?: any): AxiosPromise<string> {
            return OverlaysApiFp(configuration).channelActionAction(channel, action, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets overlay details with all widgets on it
         * @summary /:channel/:overlayId
         * @param {string} channel guid - Channel id
         * @param {string} overlayId guid - Overlay id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelOverlayId(channel: string, overlayId: string, options?: any): AxiosPromise<OverlayData> {
            return OverlaysApiFp(configuration).channelOverlayId(channel, overlayId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reloads overlays for channel
         * @summary /:channel/reload
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelReload(channel: string, options?: any): AxiosPromise<Success44> {
            return OverlaysApiFp(configuration).channelReload(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * List overlays
         * @summary /:channel
         * @param {string} search 
         * @param {string} type 
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123456789(search: string, type: string, channel: string, options?: any): AxiosPromise<OverlaysList> {
            return OverlaysApiFp(configuration).getChannel123456789(search, type, channel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OverlaysApi - object-oriented interface
 * @export
 * @class OverlaysApi
 * @extends {BaseAPI}
 */
export class OverlaysApi extends BaseAPI {
    /**
     * Overlay/Alerts control
     * @summary /:channel/action/:action
     * @param {string} channel guid - Channel id
     * @param {string} action string - one of reload, mute, unmute, pause, play
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverlaysApi
     */
    public channelActionAction(channel: string, action: string, options?: any) {
        return OverlaysApiFp(this.configuration).channelActionAction(channel, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets overlay details with all widgets on it
     * @summary /:channel/:overlayId
     * @param {string} channel guid - Channel id
     * @param {string} overlayId guid - Overlay id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverlaysApi
     */
    public channelOverlayId(channel: string, overlayId: string, options?: any) {
        return OverlaysApiFp(this.configuration).channelOverlayId(channel, overlayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reloads overlays for channel
     * @summary /:channel/reload
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverlaysApi
     */
    public channelReload(channel: string, options?: any) {
        return OverlaysApiFp(this.configuration).channelReload(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List overlays
     * @summary /:channel
     * @param {string} search 
     * @param {string} type 
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverlaysApi
     */
    public getChannel123456789(search: string, type: string, channel: string, options?: any) {
        return OverlaysApiFp(this.configuration).getChannel123456789(search, type, channel, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PointsApi - axios parameter creator
 * @export
 */
export const PointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List alltime userpoints
         * @summary /:channel/alltime
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltime: async (limit: number, offset: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelAlltime.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelAlltime.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelAlltime.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelAlltime.');
            }
            const localVarPath = `/points/{channel}/alltime`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update alltime points for user
         * @summary /:channel/alltime/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - username
         * @param {number} amount integer - amount of points to be added (negative if removed)
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltimeUserAmount: async (channel: string, user: string, amount: number, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelAlltimeUserAmount.');
            }
            const localVarPath = `/points/{channel}/alltime/{user}/{amount}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /:channel/reset/:context
         * @param {string} channel guid - Channel id
         * @param {string} context 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelResetContext: async (channel: string, context: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelResetContext.');
            }
            // verify required parameter 'context' is not null or undefined
            if (context === null || context === undefined) {
                throw new RequiredError('context','Required parameter context was null or undefined when calling channelResetContext.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelResetContext.');
            }
            const localVarPath = `/points/{channel}/reset/{context}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"context"}}`, encodeURIComponent(String(context)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get userpoints for specific username
         * @summary /:channel/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUser: async (channel: string, user: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUser.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUser.');
            }
            const localVarPath = `/points/{channel}/{user}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove points from user
         * @summary /:channel/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} amount integer - Amount of points to be added, use negative number to remove points
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserAmount: async (channel: string, user: string, amount: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUserAmount.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUserAmount.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling channelUserAmount.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUserAmount.');
            }
            const localVarPath = `/points/{channel}/{user}/{amount}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user rank by username
         * @summary /:channel/:user/rank
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserRank: async (channel: string, user: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUserRank.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUserRank.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUserRank.');
            }
            const localVarPath = `/points/{channel}/{user}/rank`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users watchtime
         * @summary /:channel/watchtime
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelWatchtime: async (limit: number, offset: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelWatchtime.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelWatchtime.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelWatchtime.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelWatchtime.');
            }
            const localVarPath = `/points/{channel}/watchtime`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List top userpoints
         * @summary /:channel/top
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTop: async (limit: number, offset: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getChannelTop.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling getChannelTop.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelTop.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannelTop.');
            }
            const localVarPath = `/points/{channel}/top`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a contest
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannel1: async (channel: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannel1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling putChannel1.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannel1.');
            }
            const localVarPath = `/points/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointsApi - functional programming interface
 * @export
 */
export const PointsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List alltime userpoints
         * @summary /:channel/alltime
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelAlltime(limit: number, offset: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelAlltime(limit, offset, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update alltime points for user
         * @summary /:channel/alltime/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - username
         * @param {number} amount integer - amount of points to be added (negative if removed)
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelAlltimeUserAmount(channel: string, user: string, amount: number, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelAlltimeUserAmount(channel, user, amount, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /:channel/reset/:context
         * @param {string} channel guid - Channel id
         * @param {string} context 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelResetContext(channel: string, context: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelResetContext(channel, context, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get userpoints for specific username
         * @summary /:channel/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUser(channel: string, user: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelUser(channel, user, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add or remove points from user
         * @summary /:channel/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} amount integer - Amount of points to be added, use negative number to remove points
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUserAmount(channel: string, user: string, amount: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelUserAmount(channel, user, amount, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get current user rank by username
         * @summary /:channel/:user/rank
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUserRank(channel: string, user: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelUserRank(channel, user, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List users watchtime
         * @summary /:channel/watchtime
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelWatchtime(limit: number, offset: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).channelWatchtime(limit, offset, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List top userpoints
         * @summary /:channel/top
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelTop(limit: number, offset: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).getChannelTop(limit, offset, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a contest
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannel1(channel: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PointsApiAxiosParamCreator(configuration).putChannel1(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PointsApi - factory interface
 * @export
 */
export const PointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List alltime userpoints
         * @summary /:channel/alltime
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltime(limit: number, offset: number, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelAlltime(limit, offset, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update alltime points for user
         * @summary /:channel/alltime/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - username
         * @param {number} amount integer - amount of points to be added (negative if removed)
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltimeUserAmount(channel: string, user: string, amount: number, accept: string, body: object, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelAlltimeUserAmount(channel, user, amount, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /:channel/reset/:context
         * @param {string} channel guid - Channel id
         * @param {string} context 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelResetContext(channel: string, context: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelResetContext(channel, context, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get userpoints for specific username
         * @summary /:channel/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUser(channel: string, user: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelUser(channel, user, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or remove points from user
         * @summary /:channel/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} amount integer - Amount of points to be added, use negative number to remove points
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserAmount(channel: string, user: string, amount: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelUserAmount(channel, user, amount, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user rank by username
         * @summary /:channel/:user/rank
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserRank(channel: string, user: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelUserRank(channel, user, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List users watchtime
         * @summary /:channel/watchtime
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelWatchtime(limit: number, offset: number, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).channelWatchtime(limit, offset, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List top userpoints
         * @summary /:channel/top
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTop(limit: number, offset: number, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).getChannelTop(limit, offset, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a contest
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannel1(channel: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return PointsApiFp(configuration).putChannel1(channel, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointsApi - object-oriented interface
 * @export
 * @class PointsApi
 * @extends {BaseAPI}
 */
export class PointsApi extends BaseAPI {
    /**
     * List alltime userpoints
     * @summary /:channel/alltime
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelAlltime(limit: number, offset: number, channel: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).channelAlltime(limit, offset, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update alltime points for user
     * @summary /:channel/alltime/:user/:amount
     * @param {string} channel guid - Channel id
     * @param {string} user string - username
     * @param {number} amount integer - amount of points to be added (negative if removed)
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelAlltimeUserAmount(channel: string, user: string, amount: number, accept: string, body: object, options?: any) {
        return PointsApiFp(this.configuration).channelAlltimeUserAmount(channel, user, amount, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /:channel/reset/:context
     * @param {string} channel guid - Channel id
     * @param {string} context 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelResetContext(channel: string, context: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).channelResetContext(channel, context, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get userpoints for specific username
     * @summary /:channel/:user
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelUser(channel: string, user: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).channelUser(channel, user, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or remove points from user
     * @summary /:channel/:user/:amount
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} amount integer - Amount of points to be added, use negative number to remove points
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelUserAmount(channel: string, user: string, amount: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).channelUserAmount(channel, user, amount, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user rank by username
     * @summary /:channel/:user/rank
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelUserRank(channel: string, user: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).channelUserRank(channel, user, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users watchtime
     * @summary /:channel/watchtime
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public channelWatchtime(limit: number, offset: number, channel: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).channelWatchtime(limit, offset, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List top userpoints
     * @summary /:channel/top
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public getChannelTop(limit: number, offset: number, channel: string, accept: string, options?: any) {
        return PointsApiFp(this.configuration).getChannelTop(limit, offset, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a contest
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointsApi
     */
    public putChannel1(channel: string, accept: string, body: string, options?: any) {
        return PointsApiFp(this.configuration).putChannel1(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RedemptionsApi - axios parameter creator
 * @export
 */
export const RedemptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List redemptions
         * @summary /:channel/redemptions
         * @param {number} offset integer - items to be skipped
         * @param {number} limit integer - limit items
         * @param {string} pending boolean
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptions: async (offset: number, limit: number, pending: string, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelRedemptions.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelRedemptions.');
            }
            // verify required parameter 'pending' is not null or undefined
            if (pending === null || pending === undefined) {
                throw new RequiredError('pending','Required parameter pending was null or undefined when calling channelRedemptions.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelRedemptions.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelRedemptions.');
            }
            const localVarPath = `/store/{channel}/redemptions`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get own redemptions
         * @summary /:channel/redemptions/me
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsMe: async (limit: number, offset: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelRedemptionsMe.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelRedemptionsMe.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelRedemptionsMe.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelRedemptionsMe.');
            }
            const localVarPath = `/store/{channel}/redemptions/me`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update redemption
         * @summary /:channel/redemptions/:redemptionId
         * @param {string} channel guid - Channel id
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsRedemptionId: async (channel: string, redemptionId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelRedemptionsRedemptionId.');
            }
            // verify required parameter 'redemptionId' is not null or undefined
            if (redemptionId === null || redemptionId === undefined) {
                throw new RequiredError('redemptionId','Required parameter redemptionId was null or undefined when calling channelRedemptionsRedemptionId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelRedemptionsRedemptionId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelRedemptionsRedemptionId.');
            }
            const localVarPath = `/store/{channel}/redemptions/{redemptionId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"redemptionId"}}`, encodeURIComponent(String(redemptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get redemption details
         * @summary /:channel/redemptions/:redemptionId1
         * @param {string} channel guid - Channel name
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsRedemptionId1: async (channel: string, redemptionId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelRedemptionsRedemptionId1.');
            }
            // verify required parameter 'redemptionId' is not null or undefined
            if (redemptionId === null || redemptionId === undefined) {
                throw new RequiredError('redemptionId','Required parameter redemptionId was null or undefined when calling channelRedemptionsRedemptionId1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelRedemptionsRedemptionId1.');
            }
            const localVarPath = `/store/{channel}/redemptions/{redemptionId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"redemptionId"}}`, encodeURIComponent(String(redemptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for redemptions
         * @summary /:channel/redemptions/search
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} search 
         * @param {string} searchBy 
         * @param {string} from 
         * @param {string} to 
         * @param {string} pending 
         * @param {string} sort 
         * @param {string} channel 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsSearch: async (offset: number, limit: number, search: string, searchBy: string, from: string, to: string, pending: string, sort: string, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'searchBy' is not null or undefined
            if (searchBy === null || searchBy === undefined) {
                throw new RequiredError('searchBy','Required parameter searchBy was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'pending' is not null or undefined
            if (pending === null || pending === undefined) {
                throw new RequiredError('pending','Required parameter pending was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelRedemptionsSearch.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelRedemptionsSearch.');
            }
            const localVarPath = `/store/{channel}/redemptions/search`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['searchBy'] = searchBy;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete redemption
         * @summary /:channel/redemptions/:redemptionId
         * @param {string} channel guid - Channel id
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelRedemptionsRedemptionId: async (channel: string, redemptionId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling deleteChannelRedemptionsRedemptionId.');
            }
            // verify required parameter 'redemptionId' is not null or undefined
            if (redemptionId === null || redemptionId === undefined) {
                throw new RequiredError('redemptionId','Required parameter redemptionId was null or undefined when calling deleteChannelRedemptionsRedemptionId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling deleteChannelRedemptionsRedemptionId.');
            }
            const localVarPath = `/store/{channel}/redemptions/{redemptionId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"redemptionId"}}`, encodeURIComponent(String(redemptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedemptionsApi - functional programming interface
 * @export
 */
export const RedemptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List redemptions
         * @summary /:channel/redemptions
         * @param {number} offset integer - items to be skipped
         * @param {number} limit integer - limit items
         * @param {string} pending boolean
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelRedemptions(offset: number, limit: number, pending: string, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RedemptionsApiAxiosParamCreator(configuration).channelRedemptions(offset, limit, pending, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get own redemptions
         * @summary /:channel/redemptions/me
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelRedemptionsMe(limit: number, offset: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RedemptionsApiAxiosParamCreator(configuration).channelRedemptionsMe(limit, offset, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update redemption
         * @summary /:channel/redemptions/:redemptionId
         * @param {string} channel guid - Channel id
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelRedemptionsRedemptionId(channel: string, redemptionId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RedemptionsApiAxiosParamCreator(configuration).channelRedemptionsRedemptionId(channel, redemptionId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get redemption details
         * @summary /:channel/redemptions/:redemptionId1
         * @param {string} channel guid - Channel name
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelRedemptionsRedemptionId1(channel: string, redemptionId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RedemptionsApiAxiosParamCreator(configuration).channelRedemptionsRedemptionId1(channel, redemptionId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search for redemptions
         * @summary /:channel/redemptions/search
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} search 
         * @param {string} searchBy 
         * @param {string} from 
         * @param {string} to 
         * @param {string} pending 
         * @param {string} sort 
         * @param {string} channel 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelRedemptionsSearch(offset: number, limit: number, search: string, searchBy: string, from: string, to: string, pending: string, sort: string, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RedemptionsApiAxiosParamCreator(configuration).channelRedemptionsSearch(offset, limit, search, searchBy, from, to, pending, sort, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete redemption
         * @summary /:channel/redemptions/:redemptionId
         * @param {string} channel guid - Channel id
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannelRedemptionsRedemptionId(channel: string, redemptionId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RedemptionsApiAxiosParamCreator(configuration).deleteChannelRedemptionsRedemptionId(channel, redemptionId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RedemptionsApi - factory interface
 * @export
 */
export const RedemptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List redemptions
         * @summary /:channel/redemptions
         * @param {number} offset integer - items to be skipped
         * @param {number} limit integer - limit items
         * @param {string} pending boolean
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptions(offset: number, limit: number, pending: string, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return RedemptionsApiFp(configuration).channelRedemptions(offset, limit, pending, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get own redemptions
         * @summary /:channel/redemptions/me
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsMe(limit: number, offset: number, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return RedemptionsApiFp(configuration).channelRedemptionsMe(limit, offset, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update redemption
         * @summary /:channel/redemptions/:redemptionId
         * @param {string} channel guid - Channel id
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsRedemptionId(channel: string, redemptionId: string, accept: string, body: object, options?: any): AxiosPromise<void> {
            return RedemptionsApiFp(configuration).channelRedemptionsRedemptionId(channel, redemptionId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get redemption details
         * @summary /:channel/redemptions/:redemptionId1
         * @param {string} channel guid - Channel name
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsRedemptionId1(channel: string, redemptionId: string, accept: string, options?: any): AxiosPromise<void> {
            return RedemptionsApiFp(configuration).channelRedemptionsRedemptionId1(channel, redemptionId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for redemptions
         * @summary /:channel/redemptions/search
         * @param {number} offset 
         * @param {number} limit 
         * @param {string} search 
         * @param {string} searchBy 
         * @param {string} from 
         * @param {string} to 
         * @param {string} pending 
         * @param {string} sort 
         * @param {string} channel 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelRedemptionsSearch(offset: number, limit: number, search: string, searchBy: string, from: string, to: string, pending: string, sort: string, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return RedemptionsApiFp(configuration).channelRedemptionsSearch(offset, limit, search, searchBy, from, to, pending, sort, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete redemption
         * @summary /:channel/redemptions/:redemptionId
         * @param {string} channel guid - Channel id
         * @param {string} redemptionId guid - Redemption id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelRedemptionsRedemptionId(channel: string, redemptionId: string, accept: string, options?: any): AxiosPromise<void> {
            return RedemptionsApiFp(configuration).deleteChannelRedemptionsRedemptionId(channel, redemptionId, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RedemptionsApi - object-oriented interface
 * @export
 * @class RedemptionsApi
 * @extends {BaseAPI}
 */
export class RedemptionsApi extends BaseAPI {
    /**
     * List redemptions
     * @summary /:channel/redemptions
     * @param {number} offset integer - items to be skipped
     * @param {number} limit integer - limit items
     * @param {string} pending boolean
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedemptionsApi
     */
    public channelRedemptions(offset: number, limit: number, pending: string, channel: string, accept: string, options?: any) {
        return RedemptionsApiFp(this.configuration).channelRedemptions(offset, limit, pending, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get own redemptions
     * @summary /:channel/redemptions/me
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedemptionsApi
     */
    public channelRedemptionsMe(limit: number, offset: number, channel: string, accept: string, options?: any) {
        return RedemptionsApiFp(this.configuration).channelRedemptionsMe(limit, offset, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update redemption
     * @summary /:channel/redemptions/:redemptionId
     * @param {string} channel guid - Channel id
     * @param {string} redemptionId guid - Redemption id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedemptionsApi
     */
    public channelRedemptionsRedemptionId(channel: string, redemptionId: string, accept: string, body: object, options?: any) {
        return RedemptionsApiFp(this.configuration).channelRedemptionsRedemptionId(channel, redemptionId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get redemption details
     * @summary /:channel/redemptions/:redemptionId1
     * @param {string} channel guid - Channel name
     * @param {string} redemptionId guid - Redemption id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedemptionsApi
     */
    public channelRedemptionsRedemptionId1(channel: string, redemptionId: string, accept: string, options?: any) {
        return RedemptionsApiFp(this.configuration).channelRedemptionsRedemptionId1(channel, redemptionId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for redemptions
     * @summary /:channel/redemptions/search
     * @param {number} offset 
     * @param {number} limit 
     * @param {string} search 
     * @param {string} searchBy 
     * @param {string} from 
     * @param {string} to 
     * @param {string} pending 
     * @param {string} sort 
     * @param {string} channel 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedemptionsApi
     */
    public channelRedemptionsSearch(offset: number, limit: number, search: string, searchBy: string, from: string, to: string, pending: string, sort: string, channel: string, accept: string, options?: any) {
        return RedemptionsApiFp(this.configuration).channelRedemptionsSearch(offset, limit, search, searchBy, from, to, pending, sort, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete redemption
     * @summary /:channel/redemptions/:redemptionId
     * @param {string} channel guid - Channel id
     * @param {string} redemptionId guid - Redemption id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedemptionsApi
     */
    public deleteChannelRedemptionsRedemptionId(channel: string, redemptionId: string, accept: string, options?: any) {
        return RedemptionsApiFp(this.configuration).deleteChannelRedemptionsRedemptionId(channel, redemptionId, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reset session data
         * @summary /:channel/reset
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelReset: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelReset.');
            }
            const localVarPath = `/sessions/{channel}/reset`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSettings: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelSettings.');
            }
            const localVarPath = `/sessions/{channel}/settings`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get session data
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12345678910: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel12345678910.');
            }
            const localVarPath = `/sessions/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get top events from aggregates
         * @summary /:channel/top
         * @param {number} limit integer - Max number of returned events
         * @param {number} offset integer - starting element
         * @param {string} interval string - Possible values: alltime, monthly, weekly, session
         * @param {string} type string - Possible values: tip, cheer, stars, embers,
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTop1: async (limit: number, offset: number, interval: string, type: string, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getChannelTop1.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling getChannelTop1.');
            }
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError('interval','Required parameter interval was null or undefined when calling getChannelTop1.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getChannelTop1.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelTop1.');
            }
            const localVarPath = `/sessions/{channel}/top`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update session data
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannel12: async (channel: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannel12.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannel12.');
            }
            const localVarPath = `/sessions/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update session settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelSettings: async (channel: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannelSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannelSettings.');
            }
            const localVarPath = `/sessions/{channel}/settings`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Reset session data
         * @summary /:channel/reset
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelReset(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model13Achannel1reset>> {
            const localVarAxiosArgs = await SessionsApiAxiosParamCreator(configuration).channelReset(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get session settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelSettings(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionSettings>> {
            const localVarAxiosArgs = await SessionsApiAxiosParamCreator(configuration).channelSettings(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get session data
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel12345678910(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionDataInfo>> {
            const localVarAxiosArgs = await SessionsApiAxiosParamCreator(configuration).getChannel12345678910(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get top events from aggregates
         * @summary /:channel/top
         * @param {number} limit integer - Max number of returned events
         * @param {number} offset integer - starting element
         * @param {string} interval string - Possible values: alltime, monthly, weekly, session
         * @param {string} type string - Possible values: tip, cheer, stars, embers,
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelTop1(limit: number, offset: number, interval: string, type: string, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionsApiAxiosParamCreator(configuration).getChannelTop1(limit, offset, interval, type, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update session data
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannel12(channel: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelData>> {
            const localVarAxiosArgs = await SessionsApiAxiosParamCreator(configuration).putChannel12(channel, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update session settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelSettings(channel: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model13Achannel1settings>> {
            const localVarAxiosArgs = await SessionsApiAxiosParamCreator(configuration).putChannelSettings(channel, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Reset session data
         * @summary /:channel/reset
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelReset(channel: string, options?: any): AxiosPromise<Model13Achannel1reset> {
            return SessionsApiFp(configuration).channelReset(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSettings(channel: string, options?: any): AxiosPromise<SessionSettings> {
            return SessionsApiFp(configuration).channelSettings(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session data
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel12345678910(channel: string, options?: any): AxiosPromise<SessionDataInfo> {
            return SessionsApiFp(configuration).getChannel12345678910(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get top events from aggregates
         * @summary /:channel/top
         * @param {number} limit integer - Max number of returned events
         * @param {number} offset integer - starting element
         * @param {string} interval string - Possible values: alltime, monthly, weekly, session
         * @param {string} type string - Possible values: tip, cheer, stars, embers,
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTop1(limit: number, offset: number, interval: string, type: string, channel: string, options?: any): AxiosPromise<void> {
            return SessionsApiFp(configuration).getChannelTop1(limit, offset, interval, type, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Update session data
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannel12(channel: string, body: object, options?: any): AxiosPromise<ChannelData> {
            return SessionsApiFp(configuration).putChannel12(channel, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update session settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelSettings(channel: string, body: object, options?: any): AxiosPromise<Model13Achannel1settings> {
            return SessionsApiFp(configuration).putChannelSettings(channel, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Reset session data
     * @summary /:channel/reset
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public channelReset(channel: string, options?: any) {
        return SessionsApiFp(this.configuration).channelReset(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session settings
     * @summary /:channel/settings
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public channelSettings(channel: string, options?: any) {
        return SessionsApiFp(this.configuration).channelSettings(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get session data
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getChannel12345678910(channel: string, options?: any) {
        return SessionsApiFp(this.configuration).getChannel12345678910(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get top events from aggregates
     * @summary /:channel/top
     * @param {number} limit integer - Max number of returned events
     * @param {number} offset integer - starting element
     * @param {string} interval string - Possible values: alltime, monthly, weekly, session
     * @param {string} type string - Possible values: tip, cheer, stars, embers,
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public getChannelTop1(limit: number, offset: number, interval: string, type: string, channel: string, options?: any) {
        return SessionsApiFp(this.configuration).getChannelTop1(limit, offset, interval, type, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update session data
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public putChannel12(channel: string, body: object, options?: any) {
        return SessionsApiFp(this.configuration).putChannel12(channel, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update session settings
     * @summary /:channel/settings
     * @param {string} channel guid - Channel id
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public putChannelSettings(channel: string, body: object, options?: any) {
        return SessionsApiFp(this.configuration).putChannelSettings(channel, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SingleContestApi - axios parameter creator
 * @export
 */
export const SingleContestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List contests
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestId: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestId.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestId.');
            }
            const localVarPath = `/contests/{channel}/{contestId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close contest
         * @summary /:channel/:contestId1
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestId1: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestId1.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestId1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestId1.');
            }
            const localVarPath = `/contests/{channel}/{contestId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place a bet on selected option
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdBet: async (channel: string, contestId: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdBet.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdBet.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdBet.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelContestIdBet.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/bet`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close contest
         * @summary /:channel/:contestId/close
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdClose: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdClose.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdClose.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdClose.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/close`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund users participating in contest
         * @summary /:channel/:contestId/refund
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdRefund: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdRefund.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdRefund.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdRefund.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/refund`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a contest
         * @summary /:channel/:contestId/start
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdStart: async (channel: string, contestId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdStart.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdStart.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdStart.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelContestIdStart.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/start`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Draw a winner of contest
         * @summary /:channel/:contestId/winner
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdWinner: async (channel: string, contestId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelContestIdWinner.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling channelContestIdWinner.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelContestIdWinner.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelContestIdWinner.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/winner`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests bets
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel Id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelContestIdBet: async (channel: string, contestId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelContestIdBet.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling getChannelContestIdBet.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannelContestIdBet.');
            }
            const localVarPath = `/contests/{channel}/{contestId}/bet`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update contest
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelContestId: async (channel: string, contestId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannelContestId.');
            }
            // verify required parameter 'contestId' is not null or undefined
            if (contestId === null || contestId === undefined) {
                throw new RequiredError('contestId','Required parameter contestId was null or undefined when calling putChannelContestId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling putChannelContestId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannelContestId.');
            }
            const localVarPath = `/contests/{channel}/{contestId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"contestId"}}`, encodeURIComponent(String(contestId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingleContestApi - functional programming interface
 * @export
 */
export const SingleContestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List contests
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestId(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contest>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestId(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Close contest
         * @summary /:channel/:contestId1
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestId1(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestId1(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Place a bet on selected option
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdBet(channel: string, contestId: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestIdBet(channel, contestId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Close contest
         * @summary /:channel/:contestId/close
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdClose(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestIdClose(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Refund users participating in contest
         * @summary /:channel/:contestId/refund
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdRefund(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestIdRefund(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a contest
         * @summary /:channel/:contestId/start
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdStart(channel: string, contestId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contest>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestIdStart(channel, contestId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Draw a winner of contest
         * @summary /:channel/:contestId/winner
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelContestIdWinner(channel: string, contestId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).channelContestIdWinner(channel, contestId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get contests bets
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel Id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelContestIdBet(channel: string, contestId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).getChannelContestIdBet(channel, contestId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update contest
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelContestId(channel: string, contestId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleContestApiAxiosParamCreator(configuration).putChannelContestId(channel, contestId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SingleContestApi - factory interface
 * @export
 */
export const SingleContestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List contests
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestId(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<Contest> {
            return SingleContestApiFp(configuration).channelContestId(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Close contest
         * @summary /:channel/:contestId1
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestId1(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<object> {
            return SingleContestApiFp(configuration).channelContestId1(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Place a bet on selected option
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdBet(channel: string, contestId: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return SingleContestApiFp(configuration).channelContestIdBet(channel, contestId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Close contest
         * @summary /:channel/:contestId/close
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdClose(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<string> {
            return SingleContestApiFp(configuration).channelContestIdClose(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund users participating in contest
         * @summary /:channel/:contestId/refund
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdRefund(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleContestApiFp(configuration).channelContestIdRefund(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a contest
         * @summary /:channel/:contestId/start
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdStart(channel: string, contestId: string, accept: string, body: object, options?: any): AxiosPromise<Contest> {
            return SingleContestApiFp(configuration).channelContestIdStart(channel, contestId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Draw a winner of contest
         * @summary /:channel/:contestId/winner
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelContestIdWinner(channel: string, contestId: string, accept: string, body: object, options?: any): AxiosPromise<string> {
            return SingleContestApiFp(configuration).channelContestIdWinner(channel, contestId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests bets
         * @summary /:channel/:contestId/bet
         * @param {string} channel guid - Channel Id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelContestIdBet(channel: string, contestId: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleContestApiFp(configuration).getChannelContestIdBet(channel, contestId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update contest
         * @summary /:channel/:contestId
         * @param {string} channel guid - Channel id
         * @param {string} contestId guid - Contest id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelContestId(channel: string, contestId: string, accept: string, body: object, options?: any): AxiosPromise<void> {
            return SingleContestApiFp(configuration).putChannelContestId(channel, contestId, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SingleContestApi - object-oriented interface
 * @export
 * @class SingleContestApi
 * @extends {BaseAPI}
 */
export class SingleContestApi extends BaseAPI {
    /**
     * List contests
     * @summary /:channel/:contestId
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestId(channel: string, contestId: string, accept: string, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestId(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close contest
     * @summary /:channel/:contestId1
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestId1(channel: string, contestId: string, accept: string, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestId1(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place a bet on selected option
     * @summary /:channel/:contestId/bet
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestIdBet(channel: string, contestId: string, accept: string, body: string, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestIdBet(channel, contestId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close contest
     * @summary /:channel/:contestId/close
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestIdClose(channel: string, contestId: string, accept: string, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestIdClose(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund users participating in contest
     * @summary /:channel/:contestId/refund
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestIdRefund(channel: string, contestId: string, accept: string, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestIdRefund(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a contest
     * @summary /:channel/:contestId/start
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestIdStart(channel: string, contestId: string, accept: string, body: object, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestIdStart(channel, contestId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Draw a winner of contest
     * @summary /:channel/:contestId/winner
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public channelContestIdWinner(channel: string, contestId: string, accept: string, body: object, options?: any) {
        return SingleContestApiFp(this.configuration).channelContestIdWinner(channel, contestId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests bets
     * @summary /:channel/:contestId/bet
     * @param {string} channel guid - Channel Id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public getChannelContestIdBet(channel: string, contestId: string, accept: string, options?: any) {
        return SingleContestApiFp(this.configuration).getChannelContestIdBet(channel, contestId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update contest
     * @summary /:channel/:contestId
     * @param {string} channel guid - Channel id
     * @param {string} contestId guid - Contest id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleContestApi
     */
    public putChannelContestId(channel: string, contestId: string, accept: string, body: object, options?: any) {
        return SingleContestApiFp(this.configuration).putChannelContestId(channel, contestId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SingleGiveawayApi - axios parameter creator
 * @export
 */
export const SingleGiveawayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get giveaway details
         * @summary /:channel/:giveawayId
         * @param {string} entrants boolean
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayId: async (entrants: string, channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entrants' is not null or undefined
            if (entrants === null || entrants === undefined) {
                throw new RequiredError('entrants','Required parameter entrants was null or undefined when calling channelGiveawayId.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayId.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayId.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (entrants !== undefined) {
                localVarQueryParameter['entrants'] = entrants;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update giveaway details
         * @summary /:channel/:giveawayId1
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayId1: async (channel: string, giveawayId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayId1.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayId1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayId1.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelGiveawayId1.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close current giveaway
         * @summary /:channel/:giveawayId/close
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdClose: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdClose.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdClose.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdClose.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/close`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark giveaway as complete
         * @summary /:channel/:giveawayId/complete
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdComplete: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdComplete.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdComplete.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdComplete.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/complete`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List giveaways
         * @summary /:channel/:giveawayId/joined
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdJoined: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdJoined.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdJoined.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdJoined.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/joined`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/refund
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdRefund: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdRefund.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdRefund.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdRefund.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/refund`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reopen giveaway
         * @summary /:channel/:giveawayId/reopen
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdReopen: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdReopen.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdReopen.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdReopen.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/reopen`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/start
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdStart: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdStart.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdStart.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdStart.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/start`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Draw a giveaway winner
         * @summary /:channel/:giveawayId/winner
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdWinner: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelGiveawayIdWinner.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling channelGiveawayIdWinner.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelGiveawayIdWinner.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}/winner`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete giveaway
         * @summary /:channel/:giveawayId
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelGiveawayId: async (channel: string, giveawayId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling deleteChannelGiveawayId.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling deleteChannelGiveawayId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling deleteChannelGiveawayId.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new giveaway
         * @summary /:channel/:giveawayId
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid|empty - Giveaway id or no value for ongoing giveaway
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelGiveawayId: async (channel: string, giveawayId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannelGiveawayId.');
            }
            // verify required parameter 'giveawayId' is not null or undefined
            if (giveawayId === null || giveawayId === undefined) {
                throw new RequiredError('giveawayId','Required parameter giveawayId was null or undefined when calling postChannelGiveawayId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannelGiveawayId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannelGiveawayId.');
            }
            const localVarPath = `/giveaways/{channel}/{giveawayId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"giveawayId"}}`, encodeURIComponent(String(giveawayId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingleGiveawayApi - functional programming interface
 * @export
 */
export const SingleGiveawayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get giveaway details
         * @summary /:channel/:giveawayId
         * @param {string} entrants boolean
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayId(entrants: string, channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaways>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayId(entrants, channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update giveaway details
         * @summary /:channel/:giveawayId1
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayId1(channel: string, giveawayId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaway>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayId1(channel, giveawayId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Close current giveaway
         * @summary /:channel/:giveawayId/close
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdClose(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdClose(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Mark giveaway as complete
         * @summary /:channel/:giveawayId/complete
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdComplete(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdComplete(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List giveaways
         * @summary /:channel/:giveawayId/joined
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdJoined(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GiveawayUserList>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdJoined(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/refund
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdRefund(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdRefund(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reopen giveaway
         * @summary /:channel/:giveawayId/reopen
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdReopen(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdReopen(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/start
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdStart(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaway>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdStart(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Draw a giveaway winner
         * @summary /:channel/:giveawayId/winner
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGiveawayIdWinner(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).channelGiveawayIdWinner(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete giveaway
         * @summary /:channel/:giveawayId
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannelGiveawayId(channel: string, giveawayId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).deleteChannelGiveawayId(channel, giveawayId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new giveaway
         * @summary /:channel/:giveawayId
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid|empty - Giveaway id or no value for ongoing giveaway
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannelGiveawayId(channel: string, giveawayId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Giveaway>> {
            const localVarAxiosArgs = await SingleGiveawayApiAxiosParamCreator(configuration).postChannelGiveawayId(channel, giveawayId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SingleGiveawayApi - factory interface
 * @export
 */
export const SingleGiveawayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get giveaway details
         * @summary /:channel/:giveawayId
         * @param {string} entrants boolean
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayId(entrants: string, channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<Giveaways> {
            return SingleGiveawayApiFp(configuration).channelGiveawayId(entrants, channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update giveaway details
         * @summary /:channel/:giveawayId1
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayId1(channel: string, giveawayId: string, accept: string, body: object, options?: any): AxiosPromise<Giveaway> {
            return SingleGiveawayApiFp(configuration).channelGiveawayId1(channel, giveawayId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Close current giveaway
         * @summary /:channel/:giveawayId/close
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdClose(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdClose(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark giveaway as complete
         * @summary /:channel/:giveawayId/complete
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdComplete(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdComplete(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * List giveaways
         * @summary /:channel/:giveawayId/joined
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdJoined(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<GiveawayUserList> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdJoined(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/refund
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdRefund(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdRefund(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Reopen giveaway
         * @summary /:channel/:giveawayId/reopen
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdReopen(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<string> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdReopen(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a giveaway
         * @summary /:channel/:giveawayId/start
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdStart(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<Giveaway> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdStart(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Draw a giveaway winner
         * @summary /:channel/:giveawayId/winner
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGiveawayIdWinner(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleGiveawayApiFp(configuration).channelGiveawayIdWinner(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete giveaway
         * @summary /:channel/:giveawayId
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid - Giveaway id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelGiveawayId(channel: string, giveawayId: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleGiveawayApiFp(configuration).deleteChannelGiveawayId(channel, giveawayId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new giveaway
         * @summary /:channel/:giveawayId
         * @param {string} channel guid - Channel id
         * @param {string} giveawayId guid|empty - Giveaway id or no value for ongoing giveaway
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelGiveawayId(channel: string, giveawayId: string, accept: string, body: object, options?: any): AxiosPromise<Giveaway> {
            return SingleGiveawayApiFp(configuration).postChannelGiveawayId(channel, giveawayId, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SingleGiveawayApi - object-oriented interface
 * @export
 * @class SingleGiveawayApi
 * @extends {BaseAPI}
 */
export class SingleGiveawayApi extends BaseAPI {
    /**
     * Get giveaway details
     * @summary /:channel/:giveawayId
     * @param {string} entrants boolean
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayId(entrants: string, channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayId(entrants, channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update giveaway details
     * @summary /:channel/:giveawayId1
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayId1(channel: string, giveawayId: string, accept: string, body: object, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayId1(channel, giveawayId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close current giveaway
     * @summary /:channel/:giveawayId/close
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdClose(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdClose(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark giveaway as complete
     * @summary /:channel/:giveawayId/complete
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdComplete(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdComplete(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List giveaways
     * @summary /:channel/:giveawayId/joined
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdJoined(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdJoined(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a giveaway
     * @summary /:channel/:giveawayId/refund
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdRefund(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdRefund(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reopen giveaway
     * @summary /:channel/:giveawayId/reopen
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdReopen(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdReopen(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a giveaway
     * @summary /:channel/:giveawayId/start
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdStart(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdStart(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Draw a giveaway winner
     * @summary /:channel/:giveawayId/winner
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public channelGiveawayIdWinner(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).channelGiveawayIdWinner(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete giveaway
     * @summary /:channel/:giveawayId
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid - Giveaway id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public deleteChannelGiveawayId(channel: string, giveawayId: string, accept: string, options?: any) {
        return SingleGiveawayApiFp(this.configuration).deleteChannelGiveawayId(channel, giveawayId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new giveaway
     * @summary /:channel/:giveawayId
     * @param {string} channel guid - Channel id
     * @param {string} giveawayId guid|empty - Giveaway id or no value for ongoing giveaway
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleGiveawayApi
     */
    public postChannelGiveawayId(channel: string, giveawayId: string, accept: string, body: object, options?: any) {
        return SingleGiveawayApiFp(this.configuration).postChannelGiveawayId(channel, giveawayId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SingleUserApi - axios parameter creator
 * @export
 */
export const SingleUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary /:channel/alltime/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltimeUser: async (channel: string, user: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelAlltimeUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelAlltimeUser.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelAlltimeUser.');
            }
            const localVarPath = `/points/{channel}/alltime/{user}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update alltime points for user
         * @summary /:channel/alltime/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - username
         * @param {number} amount integer - amount of points to be added (negative if removed)
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltimeUserAmount: async (channel: string, user: string, amount: number, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelAlltimeUserAmount.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelAlltimeUserAmount.');
            }
            const localVarPath = `/points/{channel}/alltime/{user}/{amount}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get userpoints for specific username
         * @summary /:channel/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUser: async (channel: string, user: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUser.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUser.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUser.');
            }
            const localVarPath = `/points/{channel}/{user}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset user points (remove from table)
         * @summary /:channel/:user1
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUser1: async (channel: string, user: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUser1.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUser1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUser1.');
            }
            const localVarPath = `/points/{channel}/{user}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove points from user
         * @summary /:channel/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} amount integer - Amount of points to be added, use negative number to remove points
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserAmount: async (channel: string, user: string, amount: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUserAmount.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUserAmount.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling channelUserAmount.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUserAmount.');
            }
            const localVarPath = `/points/{channel}/{user}/{amount}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"amount"}}`, encodeURIComponent(String(amount)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user rank by username
         * @summary /:channel/:user/rank
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserRank: async (channel: string, user: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelUserRank.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling channelUserRank.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelUserRank.');
            }
            const localVarPath = `/points/{channel}/{user}/rank`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingleUserApi - functional programming interface
 * @export
 */
export const SingleUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary /:channel/alltime/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelAlltimeUser(channel: string, user: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleUserApiAxiosParamCreator(configuration).channelAlltimeUser(channel, user, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update alltime points for user
         * @summary /:channel/alltime/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - username
         * @param {number} amount integer - amount of points to be added (negative if removed)
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelAlltimeUserAmount(channel: string, user: string, amount: number, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleUserApiAxiosParamCreator(configuration).channelAlltimeUserAmount(channel, user, amount, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get userpoints for specific username
         * @summary /:channel/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUser(channel: string, user: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleUserApiAxiosParamCreator(configuration).channelUser(channel, user, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reset user points (remove from table)
         * @summary /:channel/:user1
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUser1(channel: string, user: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleUserApiAxiosParamCreator(configuration).channelUser1(channel, user, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add or remove points from user
         * @summary /:channel/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} amount integer - Amount of points to be added, use negative number to remove points
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUserAmount(channel: string, user: string, amount: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleUserApiAxiosParamCreator(configuration).channelUserAmount(channel, user, amount, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get current user rank by username
         * @summary /:channel/:user/rank
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUserRank(channel: string, user: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SingleUserApiAxiosParamCreator(configuration).channelUserRank(channel, user, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SingleUserApi - factory interface
 * @export
 */
export const SingleUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary /:channel/alltime/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltimeUser(channel: string, user: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleUserApiFp(configuration).channelAlltimeUser(channel, user, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Update alltime points for user
         * @summary /:channel/alltime/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - username
         * @param {number} amount integer - amount of points to be added (negative if removed)
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAlltimeUserAmount(channel: string, user: string, amount: number, accept: string, body: object, options?: any): AxiosPromise<void> {
            return SingleUserApiFp(configuration).channelAlltimeUserAmount(channel, user, amount, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get userpoints for specific username
         * @summary /:channel/:user
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUser(channel: string, user: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleUserApiFp(configuration).channelUser(channel, user, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset user points (remove from table)
         * @summary /:channel/:user1
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUser1(channel: string, user: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleUserApiFp(configuration).channelUser1(channel, user, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or remove points from user
         * @summary /:channel/:user/:amount
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} amount integer - Amount of points to be added, use negative number to remove points
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserAmount(channel: string, user: string, amount: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleUserApiFp(configuration).channelUserAmount(channel, user, amount, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user rank by username
         * @summary /:channel/:user/rank
         * @param {string} channel guid - Channel id
         * @param {string} user string - Username
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUserRank(channel: string, user: string, accept: string, options?: any): AxiosPromise<void> {
            return SingleUserApiFp(configuration).channelUserRank(channel, user, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SingleUserApi - object-oriented interface
 * @export
 * @class SingleUserApi
 * @extends {BaseAPI}
 */
export class SingleUserApi extends BaseAPI {
    /**
     * 
     * @summary /:channel/alltime/:user
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleUserApi
     */
    public channelAlltimeUser(channel: string, user: string, accept: string, options?: any) {
        return SingleUserApiFp(this.configuration).channelAlltimeUser(channel, user, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update alltime points for user
     * @summary /:channel/alltime/:user/:amount
     * @param {string} channel guid - Channel id
     * @param {string} user string - username
     * @param {number} amount integer - amount of points to be added (negative if removed)
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleUserApi
     */
    public channelAlltimeUserAmount(channel: string, user: string, amount: number, accept: string, body: object, options?: any) {
        return SingleUserApiFp(this.configuration).channelAlltimeUserAmount(channel, user, amount, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get userpoints for specific username
     * @summary /:channel/:user
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleUserApi
     */
    public channelUser(channel: string, user: string, accept: string, options?: any) {
        return SingleUserApiFp(this.configuration).channelUser(channel, user, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset user points (remove from table)
     * @summary /:channel/:user1
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleUserApi
     */
    public channelUser1(channel: string, user: string, accept: string, options?: any) {
        return SingleUserApiFp(this.configuration).channelUser1(channel, user, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or remove points from user
     * @summary /:channel/:user/:amount
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} amount integer - Amount of points to be added, use negative number to remove points
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleUserApi
     */
    public channelUserAmount(channel: string, user: string, amount: string, accept: string, options?: any) {
        return SingleUserApiFp(this.configuration).channelUserAmount(channel, user, amount, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user rank by username
     * @summary /:channel/:user/rank
     * @param {string} channel guid - Channel id
     * @param {string} user string - Username
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleUserApi
     */
    public channelUserRank(channel: string, user: string, accept: string, options?: any) {
        return SingleUserApiFp(this.configuration).channelUserRank(channel, user, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SongrequestsApi - axios parameter creator
 * @export
 */
export const SongrequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get details of next song in queue
         * @summary /:channel/next
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelNext: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelNext.');
            }
            const localVarPath = `/songrequest/{channel}/next`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get songs in moderation queue
         * @summary /:channel/pending
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPending: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPending.');
            }
            const localVarPath = `/songrequest/{channel}/pending`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current player status
         * @summary /:channel/player
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlayer: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPlayer.');
            }
            const localVarPath = `/songrequest/{channel}/player`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change current state of media player
         * @summary /:channel/player/:state
         * @param {string} channel guid - Channel id
         * @param {string} state string - one of play, pause
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlayerState: async (channel: string, state: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPlayerState.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling channelPlayerState.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelPlayerState.');
            }
            const localVarPath = `/songrequest/{channel}/player/{state}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"state"}}`, encodeURIComponent(String(state)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get currently playing song
         * @summary /:channel/playing
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlaying: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPlaying.');
            }
            const localVarPath = `/songrequest/{channel}/playing`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get songs on playlist
         * @summary /:channel/playlist
         * @param {number} limit integer - number of results per page
         * @param {string} page string - page identifier as in nextPage
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlaylist: async (limit: number, page: string, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelPlaylist.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling channelPlaylist.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelPlaylist.');
            }
            const localVarPath = `/songrequest/{channel}/playlist`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get songrequest queue
         * @summary /:channel/queue
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelQueue: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelQueue.');
            }
            const localVarPath = `/songrequest/{channel}/queue`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get songrequest queue for public exposure (without video details)
         * @summary /:channel/queue/public
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelQueuePublic: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelQueuePublic.');
            }
            const localVarPath = `/songrequest/{channel}/queue/public`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove song from queue
         * @summary /:channel/queue/:song
         * @param {string} channel guid - Channel id
         * @param {string} song guid - Song id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelQueueSong: async (channel: string, song: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelQueueSong.');
            }
            // verify required parameter 'song' is not null or undefined
            if (song === null || song === undefined) {
                throw new RequiredError('song','Required parameter song was null or undefined when calling channelQueueSong.');
            }
            const localVarPath = `/songrequest/{channel}/queue/{song}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"song"}}`, encodeURIComponent(String(song)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public settings
         * @summary /:channel/settings/public
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSettingsPublic: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelSettingsPublic.');
            }
            const localVarPath = `/songrequest/{channel}/settings/public`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get songrequest history
         * @summary /:channel/history
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelHistory1: async (limit: number, offset: number, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getChannelHistory1.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling getChannelHistory1.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelHistory1.');
            }
            const localVarPath = `/songrequest/{channel}/history`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSettings: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelSettings.');
            }
            const localVarPath = `/songrequest/{channel}/settings`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /playing
         * @param {string} provider 
         * @param {string} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playing: async (provider: string, room: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            if (provider === null || provider === undefined) {
                throw new RequiredError('provider','Required parameter provider was null or undefined when calling playing.');
            }
            // verify required parameter 'room' is not null or undefined
            if (room === null || room === undefined) {
                throw new RequiredError('room','Required parameter room was null or undefined when calling playing.');
            }
            const localVarPath = `/songrequest/playing`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (room !== undefined) {
                localVarQueryParameter['room'] = room;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get songrequest queue
         * @summary /:channel/queue
         * @param {string} channel guid - Channel id
         * @param {Model13Achannel1queuerequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelQueue: async (channel: string, body: Model13Achannel1queuerequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannelQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannelQueue.');
            }
            const localVarPath = `/songrequest/{channel}/queue`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get song details
         * @summary /youtube
         * @param {string} videoId string - YouTube video ID
         * @param {string} search string - phrase to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        youtube: async (videoId: string, search: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling youtube.');
            }
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling youtube.');
            }
            const localVarPath = `/songrequest/youtube`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (videoId !== undefined) {
                localVarQueryParameter['videoId'] = videoId;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongrequestsApi - functional programming interface
 * @export
 */
export const SongrequestsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get details of next song in queue
         * @summary /:channel/next
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelNext(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelNext(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get songs in moderation queue
         * @summary /:channel/pending
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPending(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelPending(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get current player status
         * @summary /:channel/player
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPlayer(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success53>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelPlayer(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Change current state of media player
         * @summary /:channel/player/:state
         * @param {string} channel guid - Channel id
         * @param {string} state string - one of play, pause
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPlayerState(channel: string, state: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelPlayerState(channel, state, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get currently playing song
         * @summary /:channel/playing
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPlaying(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelPlaying(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get songs on playlist
         * @summary /:channel/playlist
         * @param {number} limit integer - number of results per page
         * @param {string} page string - page identifier as in nextPage
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelPlaylist(limit: number, page: string, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRequestQueue>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelPlaylist(limit, page, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get songrequest queue
         * @summary /:channel/queue
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelQueue(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Song>>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelQueue(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get songrequest queue for public exposure (without video details)
         * @summary /:channel/queue/public
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelQueuePublic(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Song>>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelQueuePublic(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove song from queue
         * @summary /:channel/queue/:song
         * @param {string} channel guid - Channel id
         * @param {string} song guid - Song id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelQueueSong(channel: string, song: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelQueueSong(channel, song, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get public settings
         * @summary /:channel/settings/public
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelSettingsPublic(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success48>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).channelSettingsPublic(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get songrequest history
         * @summary /:channel/history
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelHistory1(limit: number, offset: number, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).getChannelHistory1(limit, offset, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelSettings(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRequestData>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).getChannelSettings(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /playing
         * @param {string} provider 
         * @param {string} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playing(provider: string, room: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).playing(provider, room, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get songrequest queue
         * @summary /:channel/queue
         * @param {string} channel guid - Channel id
         * @param {Model13Achannel1queuerequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannelQueue(channel: string, body: Model13Achannel1queuerequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).postChannelQueue(channel, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get song details
         * @summary /youtube
         * @param {string} videoId string - YouTube video ID
         * @param {string} search string - phrase to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async youtube(videoId: string, search: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SuccessSearchbysongname>>> {
            const localVarAxiosArgs = await SongrequestsApiAxiosParamCreator(configuration).youtube(videoId, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SongrequestsApi - factory interface
 * @export
 */
export const SongrequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get details of next song in queue
         * @summary /:channel/next
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelNext(channel: string, options?: any): AxiosPromise<Song> {
            return SongrequestsApiFp(configuration).channelNext(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get songs in moderation queue
         * @summary /:channel/pending
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPending(channel: string, options?: any): AxiosPromise<void> {
            return SongrequestsApiFp(configuration).channelPending(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current player status
         * @summary /:channel/player
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlayer(channel: string, options?: any): AxiosPromise<Success53> {
            return SongrequestsApiFp(configuration).channelPlayer(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Change current state of media player
         * @summary /:channel/player/:state
         * @param {string} channel guid - Channel id
         * @param {string} state string - one of play, pause
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlayerState(channel: string, state: string, contentType: string, options?: any): AxiosPromise<string> {
            return SongrequestsApiFp(configuration).channelPlayerState(channel, state, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get currently playing song
         * @summary /:channel/playing
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlaying(channel: string, options?: any): AxiosPromise<Song> {
            return SongrequestsApiFp(configuration).channelPlaying(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get songs on playlist
         * @summary /:channel/playlist
         * @param {number} limit integer - number of results per page
         * @param {string} page string - page identifier as in nextPage
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelPlaylist(limit: number, page: string, channel: string, options?: any): AxiosPromise<MediaRequestQueue> {
            return SongrequestsApiFp(configuration).channelPlaylist(limit, page, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get songrequest queue
         * @summary /:channel/queue
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelQueue(channel: string, options?: any): AxiosPromise<Array<Song>> {
            return SongrequestsApiFp(configuration).channelQueue(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get songrequest queue for public exposure (without video details)
         * @summary /:channel/queue/public
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelQueuePublic(channel: string, options?: any): AxiosPromise<Array<Song>> {
            return SongrequestsApiFp(configuration).channelQueuePublic(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove song from queue
         * @summary /:channel/queue/:song
         * @param {string} channel guid - Channel id
         * @param {string} song guid - Song id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelQueueSong(channel: string, song: string, options?: any): AxiosPromise<string> {
            return SongrequestsApiFp(configuration).channelQueueSong(channel, song, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public settings
         * @summary /:channel/settings/public
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelSettingsPublic(channel: string, options?: any): AxiosPromise<Success48> {
            return SongrequestsApiFp(configuration).channelSettingsPublic(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get songrequest history
         * @summary /:channel/history
         * @param {number} limit integer - Number of items per page
         * @param {number} offset integer - Number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelHistory1(limit: number, offset: number, channel: string, options?: any): AxiosPromise<void> {
            return SongrequestsApiFp(configuration).getChannelHistory1(limit, offset, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get settings
         * @summary /:channel/settings
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelSettings(channel: string, options?: any): AxiosPromise<MediaRequestData> {
            return SongrequestsApiFp(configuration).getChannelSettings(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /playing
         * @param {string} provider 
         * @param {string} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playing(provider: string, room: string, options?: any): AxiosPromise<void> {
            return SongrequestsApiFp(configuration).playing(provider, room, options).then((request) => request(axios, basePath));
        },
        /**
         * Get songrequest queue
         * @summary /:channel/queue
         * @param {string} channel guid - Channel id
         * @param {Model13Achannel1queuerequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelQueue(channel: string, body: Model13Achannel1queuerequest, options?: any): AxiosPromise<Song> {
            return SongrequestsApiFp(configuration).postChannelQueue(channel, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get song details
         * @summary /youtube
         * @param {string} videoId string - YouTube video ID
         * @param {string} search string - phrase to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        youtube(videoId: string, search: string, options?: any): AxiosPromise<Array<SuccessSearchbysongname>> {
            return SongrequestsApiFp(configuration).youtube(videoId, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongrequestsApi - object-oriented interface
 * @export
 * @class SongrequestsApi
 * @extends {BaseAPI}
 */
export class SongrequestsApi extends BaseAPI {
    /**
     * Get details of next song in queue
     * @summary /:channel/next
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelNext(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelNext(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get songs in moderation queue
     * @summary /:channel/pending
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelPending(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelPending(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current player status
     * @summary /:channel/player
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelPlayer(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelPlayer(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change current state of media player
     * @summary /:channel/player/:state
     * @param {string} channel guid - Channel id
     * @param {string} state string - one of play, pause
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelPlayerState(channel: string, state: string, contentType: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelPlayerState(channel, state, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get currently playing song
     * @summary /:channel/playing
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelPlaying(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelPlaying(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get songs on playlist
     * @summary /:channel/playlist
     * @param {number} limit integer - number of results per page
     * @param {string} page string - page identifier as in nextPage
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelPlaylist(limit: number, page: string, channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelPlaylist(limit, page, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get songrequest queue
     * @summary /:channel/queue
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelQueue(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelQueue(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get songrequest queue for public exposure (without video details)
     * @summary /:channel/queue/public
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelQueuePublic(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelQueuePublic(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove song from queue
     * @summary /:channel/queue/:song
     * @param {string} channel guid - Channel id
     * @param {string} song guid - Song id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelQueueSong(channel: string, song: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelQueueSong(channel, song, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public settings
     * @summary /:channel/settings/public
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public channelSettingsPublic(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).channelSettingsPublic(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get songrequest history
     * @summary /:channel/history
     * @param {number} limit integer - Number of items per page
     * @param {number} offset integer - Number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public getChannelHistory1(limit: number, offset: number, channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).getChannelHistory1(limit, offset, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get settings
     * @summary /:channel/settings
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public getChannelSettings(channel: string, options?: any) {
        return SongrequestsApiFp(this.configuration).getChannelSettings(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /playing
     * @param {string} provider 
     * @param {string} room 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public playing(provider: string, room: string, options?: any) {
        return SongrequestsApiFp(this.configuration).playing(provider, room, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get songrequest queue
     * @summary /:channel/queue
     * @param {string} channel guid - Channel id
     * @param {Model13Achannel1queuerequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public postChannelQueue(channel: string, body: Model13Achannel1queuerequest, options?: any) {
        return SongrequestsApiFp(this.configuration).postChannelQueue(channel, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get song details
     * @summary /youtube
     * @param {string} videoId string - YouTube video ID
     * @param {string} search string - phrase to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongrequestsApi
     */
    public youtube(videoId: string, search: string, options?: any) {
        return SongrequestsApiFp(this.configuration).youtube(videoId, search, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get channels stats
         * @summary /:channel
         * @param {string} interval string - year, month, week, day
         * @param {string} date datetime
         * @param {number} tz integer - timezone number
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1234567891011: async (interval: string, date: string, tz: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interval' is not null or undefined
            if (interval === null || interval === undefined) {
                throw new RequiredError('interval','Required parameter interval was null or undefined when calling getChannel1234567891011.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling getChannel1234567891011.');
            }
            // verify required parameter 'tz' is not null or undefined
            if (tz === null || tz === undefined) {
                throw new RequiredError('tz','Required parameter tz was null or undefined when calling getChannel1234567891011.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel1234567891011.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel1234567891011.');
            }
            const localVarPath = `/stats/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get channels stats
         * @summary /:channel
         * @param {string} interval string - year, month, week, day
         * @param {string} date datetime
         * @param {number} tz integer - timezone number
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel1234567891011(interval: string, date: string, tz: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StatsApiAxiosParamCreator(configuration).getChannel1234567891011(interval, date, tz, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get channels stats
         * @summary /:channel
         * @param {string} interval string - year, month, week, day
         * @param {string} date datetime
         * @param {number} tz integer - timezone number
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1234567891011(interval: string, date: string, tz: number, channel: string, accept: string, options?: any): AxiosPromise<void> {
            return StatsApiFp(configuration).getChannel1234567891011(interval, date, tz, channel, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Get channels stats
     * @summary /:channel
     * @param {string} interval string - year, month, week, day
     * @param {string} date datetime
     * @param {number} tz integer - timezone number
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getChannel1234567891011(interval: string, date: string, tz: number, channel: string, accept: string, options?: any) {
        return StatsApiFp(this.configuration).getChannel1234567891011(interval, date, tz, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List store items
         * @summary /:channel/items
         * @param {number} limit integer - number of items per page
         * @param {number} offset integer - number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelItems: async (limit: number, offset: number, channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling channelItems.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling channelItems.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelItems.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelItems.');
            }
            const localVarPath = `/store/{channel}/items`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get item details
         * @summary /:channel/items/:itemId
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelItemsItemId: async (channel: string, itemId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelItemsItemId.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling channelItemsItemId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelItemsItemId.');
            }
            const localVarPath = `/store/{channel}/items/{itemId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete item from store
         * @summary /:channel/items/:itemId1
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelItemsItemId1: async (channel: string, itemId: string, accept: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelItemsItemId1.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling channelItemsItemId1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelItemsItemId1.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling channelItemsItemId1.');
            }
            const localVarPath = `/store/{channel}/items/{itemId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new item to store
         * @summary /:channel/items
         * @param {string} channel guid - channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelItems: async (channel: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannelItems.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannelItems.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannelItems.');
            }
            const localVarPath = `/store/{channel}/items`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update item
         * @summary /:channel/items/:itemId
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelItemsItemId: async (channel: string, itemId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannelItemsItemId.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling putChannelItemsItemId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling putChannelItemsItemId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannelItemsItemId.');
            }
            const localVarPath = `/store/{channel}/items/{itemId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List store items
         * @summary /:channel/items
         * @param {number} limit integer - number of items per page
         * @param {number} offset integer - number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelItems(limit: number, offset: number, channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoyaltyItem>>> {
            const localVarAxiosArgs = await StoreApiAxiosParamCreator(configuration).channelItems(limit, offset, channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get item details
         * @summary /:channel/items/:itemId
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelItemsItemId(channel: string, itemId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoyaltyItem>> {
            const localVarAxiosArgs = await StoreApiAxiosParamCreator(configuration).channelItemsItemId(channel, itemId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete item from store
         * @summary /:channel/items/:itemId1
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelItemsItemId1(channel: string, itemId: string, accept: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await StoreApiAxiosParamCreator(configuration).channelItemsItemId1(channel, itemId, accept, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add new item to store
         * @summary /:channel/items
         * @param {string} channel guid - channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannelItems(channel: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoyaltyItem>> {
            const localVarAxiosArgs = await StoreApiAxiosParamCreator(configuration).postChannelItems(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update item
         * @summary /:channel/items/:itemId
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelItemsItemId(channel: string, itemId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoyaltyItem>> {
            const localVarAxiosArgs = await StoreApiAxiosParamCreator(configuration).putChannelItemsItemId(channel, itemId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List store items
         * @summary /:channel/items
         * @param {number} limit integer - number of items per page
         * @param {number} offset integer - number of items to be skipped
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelItems(limit: number, offset: number, channel: string, accept: string, options?: any): AxiosPromise<Array<LoyaltyItem>> {
            return StoreApiFp(configuration).channelItems(limit, offset, channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get item details
         * @summary /:channel/items/:itemId
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelItemsItemId(channel: string, itemId: string, accept: string, options?: any): AxiosPromise<LoyaltyItem> {
            return StoreApiFp(configuration).channelItemsItemId(channel, itemId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete item from store
         * @summary /:channel/items/:itemId1
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelItemsItemId1(channel: string, itemId: string, accept: string, contentType: string, options?: any): AxiosPromise<string> {
            return StoreApiFp(configuration).channelItemsItemId1(channel, itemId, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Add new item to store
         * @summary /:channel/items
         * @param {string} channel guid - channel id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannelItems(channel: string, accept: string, body: object, options?: any): AxiosPromise<LoyaltyItem> {
            return StoreApiFp(configuration).postChannelItems(channel, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update item
         * @summary /:channel/items/:itemId
         * @param {string} channel guid - Channel id
         * @param {string} itemId guid - Item id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelItemsItemId(channel: string, itemId: string, accept: string, body: object, options?: any): AxiosPromise<LoyaltyItem> {
            return StoreApiFp(configuration).putChannelItemsItemId(channel, itemId, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * List store items
     * @summary /:channel/items
     * @param {number} limit integer - number of items per page
     * @param {number} offset integer - number of items to be skipped
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public channelItems(limit: number, offset: number, channel: string, accept: string, options?: any) {
        return StoreApiFp(this.configuration).channelItems(limit, offset, channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get item details
     * @summary /:channel/items/:itemId
     * @param {string} channel guid - Channel id
     * @param {string} itemId guid - Item id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public channelItemsItemId(channel: string, itemId: string, accept: string, options?: any) {
        return StoreApiFp(this.configuration).channelItemsItemId(channel, itemId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete item from store
     * @summary /:channel/items/:itemId1
     * @param {string} channel guid - Channel id
     * @param {string} itemId guid - Item id
     * @param {string} accept 
     * @param {string} contentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public channelItemsItemId1(channel: string, itemId: string, accept: string, contentType: string, options?: any) {
        return StoreApiFp(this.configuration).channelItemsItemId1(channel, itemId, accept, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add new item to store
     * @summary /:channel/items
     * @param {string} channel guid - channel id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public postChannelItems(channel: string, accept: string, body: object, options?: any) {
        return StoreApiFp(this.configuration).postChannelItems(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update item
     * @summary /:channel/items/:itemId
     * @param {string} channel guid - Channel id
     * @param {string} itemId guid - Item id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public putChannelItemsItemId(channel: string, itemId: string, accept: string, body: object, options?: any) {
        return StoreApiFp(this.configuration).putChannelItemsItemId(channel, itemId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ThemesApi - axios parameter creator
 * @export
 */
export const ThemesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List available themes
         * @summary /
         * @param {string} type string - one of alert, regular, super mobile, widget
         * @param {string} mobile boolean
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (type: string, mobile: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling get.');
            }
            // verify required parameter 'mobile' is not null or undefined
            if (mobile === null || mobile === undefined) {
                throw new RequiredError('mobile','Required parameter mobile was null or undefined when calling get.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling get.');
            }
            const localVarPath = `/themes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mobile !== undefined) {
                localVarQueryParameter['mobile'] = mobile;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get theme details
         * @summary /:themeId
         * @param {string} themeId guid - theme id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeId: async (themeId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'themeId' is not null or undefined
            if (themeId === null || themeId === undefined) {
                throw new RequiredError('themeId','Required parameter themeId was null or undefined when calling themeId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling themeId.');
            }
            const localVarPath = `/themes/{themeId}`
                .replace(`{${"themeId"}}`, encodeURIComponent(String(themeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThemesApi - functional programming interface
 * @export
 */
export const ThemesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List available themes
         * @summary /
         * @param {string} type string - one of alert, regular, super mobile, widget
         * @param {string} mobile boolean
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(type: string, mobile: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemesList>>> {
            const localVarAxiosArgs = await ThemesApiAxiosParamCreator(configuration).get(type, mobile, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get theme details
         * @summary /:themeId
         * @param {string} themeId guid - theme id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeId(themeId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverlayData>> {
            const localVarAxiosArgs = await ThemesApiAxiosParamCreator(configuration).themeId(themeId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ThemesApi - factory interface
 * @export
 */
export const ThemesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List available themes
         * @summary /
         * @param {string} type string - one of alert, regular, super mobile, widget
         * @param {string} mobile boolean
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(type: string, mobile: string, accept: string, options?: any): AxiosPromise<Array<ThemesList>> {
            return ThemesApiFp(configuration).get(type, mobile, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get theme details
         * @summary /:themeId
         * @param {string} themeId guid - theme id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeId(themeId: string, accept: string, options?: any): AxiosPromise<OverlayData> {
            return ThemesApiFp(configuration).themeId(themeId, accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThemesApi - object-oriented interface
 * @export
 * @class ThemesApi
 * @extends {BaseAPI}
 */
export class ThemesApi extends BaseAPI {
    /**
     * List available themes
     * @summary /
     * @param {string} type string - one of alert, regular, super mobile, widget
     * @param {string} mobile boolean
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public get(type: string, mobile: string, accept: string, options?: any) {
        return ThemesApiFp(this.configuration).get(type, mobile, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get theme details
     * @summary /:themeId
     * @param {string} themeId guid - theme id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThemesApi
     */
    public themeId(themeId: string, accept: string, options?: any) {
        return ThemesApiFp(this.configuration).themeId(themeId, accept, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TimersApi - axios parameter creator
 * @export
 */
export const TimersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get timer details
         * @summary /:channel/:timerId
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTimerId: async (channel: string, timerId: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelTimerId.');
            }
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling channelTimerId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelTimerId.');
            }
            const localVarPath = `/bot/timers/{channel}/{timerId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete timer
         * @summary /:channel/:timerId1
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTimerId1: async (channel: string, timerId: string, accept: string, body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelTimerId1.');
            }
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling channelTimerId1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channelTimerId1.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling channelTimerId1.');
            }
            const localVarPath = `/bot/timers/{channel}/{timerId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List timers
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1: async (channel: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getChannel1.');
            }
            const localVarPath = `/bot/timers/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new timer
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannelrequest1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel1: async (channel: string, accept: string, body: Model13Achannelrequest1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannel1.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling postChannel1.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postChannel1.');
            }
            const localVarPath = `/bot/timers/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update timer details
         * @summary /:channel/:timerId
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelTimerId: async (channel: string, timerId: string, accept: string, body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling putChannelTimerId.');
            }
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling putChannelTimerId.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling putChannelTimerId.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putChannelTimerId.');
            }
            const localVarPath = `/bot/timers/{channel}/{timerId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimersApi - functional programming interface
 * @export
 */
export const TimersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get timer details
         * @summary /:channel/:timerId
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelTimerId(channel: string, timerId: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success11>> {
            const localVarAxiosArgs = await TimersApiAxiosParamCreator(configuration).channelTimerId(channel, timerId, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete timer
         * @summary /:channel/:timerId1
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelTimerId1(channel: string, timerId: string, accept: string, body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TimersApiAxiosParamCreator(configuration).channelTimerId1(channel, timerId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List timers
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel1(channel: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success11>>> {
            const localVarAxiosArgs = await TimersApiAxiosParamCreator(configuration).getChannel1(channel, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new timer
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannelrequest1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannel1(channel: string, accept: string, body: Model13Achannelrequest1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotCommand>> {
            const localVarAxiosArgs = await TimersApiAxiosParamCreator(configuration).postChannel1(channel, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update timer details
         * @summary /:channel/:timerId
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelTimerId(channel: string, timerId: string, accept: string, body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success11>> {
            const localVarAxiosArgs = await TimersApiAxiosParamCreator(configuration).putChannelTimerId(channel, timerId, accept, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimersApi - factory interface
 * @export
 */
export const TimersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get timer details
         * @summary /:channel/:timerId
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTimerId(channel: string, timerId: string, accept: string, options?: any): AxiosPromise<Success11> {
            return TimersApiFp(configuration).channelTimerId(channel, timerId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete timer
         * @summary /:channel/:timerId1
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTimerId1(channel: string, timerId: string, accept: string, body: string, options?: any): AxiosPromise<void> {
            return TimersApiFp(configuration).channelTimerId1(channel, timerId, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List timers
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel1(channel: string, accept: string, options?: any): AxiosPromise<Array<Success11>> {
            return TimersApiFp(configuration).getChannel1(channel, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new timer
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {string} accept 
         * @param {Model13Achannelrequest1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel1(channel: string, accept: string, body: Model13Achannelrequest1, options?: any): AxiosPromise<BotCommand> {
            return TimersApiFp(configuration).postChannel1(channel, accept, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update timer details
         * @summary /:channel/:timerId
         * @param {string} channel guid - Channel id
         * @param {string} timerId guid - Timer id
         * @param {string} accept 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelTimerId(channel: string, timerId: string, accept: string, body: object, options?: any): AxiosPromise<Success11> {
            return TimersApiFp(configuration).putChannelTimerId(channel, timerId, accept, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimersApi - object-oriented interface
 * @export
 * @class TimersApi
 * @extends {BaseAPI}
 */
export class TimersApi extends BaseAPI {
    /**
     * Get timer details
     * @summary /:channel/:timerId
     * @param {string} channel guid - Channel id
     * @param {string} timerId guid - Timer id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimersApi
     */
    public channelTimerId(channel: string, timerId: string, accept: string, options?: any) {
        return TimersApiFp(this.configuration).channelTimerId(channel, timerId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete timer
     * @summary /:channel/:timerId1
     * @param {string} channel guid - Channel id
     * @param {string} timerId guid - Timer id
     * @param {string} accept 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimersApi
     */
    public channelTimerId1(channel: string, timerId: string, accept: string, body: string, options?: any) {
        return TimersApiFp(this.configuration).channelTimerId1(channel, timerId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List timers
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimersApi
     */
    public getChannel1(channel: string, accept: string, options?: any) {
        return TimersApiFp(this.configuration).getChannel1(channel, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new timer
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {string} accept 
     * @param {Model13Achannelrequest1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimersApi
     */
    public postChannel1(channel: string, accept: string, body: Model13Achannelrequest1, options?: any) {
        return TimersApiFp(this.configuration).postChannel1(channel, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update timer details
     * @summary /:channel/:timerId
     * @param {string} channel guid - Channel id
     * @param {string} timerId guid - Timer id
     * @param {string} accept 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimersApi
     */
    public putChannelTimerId(channel: string, timerId: string, accept: string, body: object, options?: any) {
        return TimersApiFp(this.configuration).putChannelTimerId(channel, timerId, accept, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TipsApi - axios parameter creator
 * @export
 */
export const TipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get tips leaderboard
         * @summary /:channel/leaderboard
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLeaderboard: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelLeaderboard.');
            }
            const localVarPath = `/tips/{channel}/leaderboard`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tips waiting for moderation
         * @summary /:channel/moderation
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelModeration: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelModeration.');
            }
            const localVarPath = `/tips/{channel}/moderation`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tip details
         * @summary /:channel/:tipId
         * @param {string} channel guid - Channel id
         * @param {string} tipId guid - Tip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTipId: async (channel: string, tipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling channelTipId.');
            }
            // verify required parameter 'tipId' is not null or undefined
            if (tipId === null || tipId === undefined) {
                throw new RequiredError('tipId','Required parameter tipId was null or undefined when calling channelTipId.');
            }
            const localVarPath = `/tips/{channel}/{tipId}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)))
                .replace(`{${"tipId"}}`, encodeURIComponent(String(tipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tips
         * @summary /:channel
         * @param {number} offset integer - Starting element
         * @param {number} limit integer - Events per page between 1 and 100
         * @param {string} sort string - Sorting method. Possible values createdAt, -createdAt, donation.amount, -donation.amount, donation.provider, -donation.provider
         * @param {number} tz integer - Timezone number
         * @param {string} username string - Username
         * @param {string} email string - Email address
         * @param {number} after datetime - Start date
         * @param {number} before datetime - End date
         * @param {string} message string - Tip message
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123456789101112: async (offset: number, limit: number, sort: string, tz: number, username: string, email: string, after: number, before: number, message: string, channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset','Required parameter offset was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort','Required parameter sort was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'tz' is not null or undefined
            if (tz === null || tz === undefined) {
                throw new RequiredError('tz','Required parameter tz was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'after' is not null or undefined
            if (after === null || after === undefined) {
                throw new RequiredError('after','Required parameter after was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'before' is not null or undefined
            if (before === null || before === undefined) {
                throw new RequiredError('before','Required parameter before was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'message' is not null or undefined
            if (message === null || message === undefined) {
                throw new RequiredError('message','Required parameter message was null or undefined when calling getChannel123456789101112.');
            }
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannel123456789101112.');
            }
            const localVarPath = `/tips/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tz !== undefined) {
                localVarQueryParameter['tz'] = tz;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get top tippers for channel
         * @summary /:channel/top
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTop12: async (channel: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling getChannelTop12.');
            }
            const localVarPath = `/tips/{channel}/top`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {NewTip} newTip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel1234: async (channel: string, newTip: NewTip, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            if (channel === null || channel === undefined) {
                throw new RequiredError('channel','Required parameter channel was null or undefined when calling postChannel1234.');
            }
            // verify required parameter 'newTip' is not null or undefined
            if (newTip === null || newTip === undefined) {
                throw new RequiredError('newTip','Required parameter newTip was null or undefined when calling postChannel1234.');
            }
            const localVarPath = `/tips/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof newTip !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(newTip !== undefined ? newTip : {}) : (newTip || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TipsApi - functional programming interface
 * @export
 */
export const TipsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get tips leaderboard
         * @summary /:channel/leaderboard
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelLeaderboard(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TipsApiAxiosParamCreator(configuration).channelLeaderboard(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List tips waiting for moderation
         * @summary /:channel/moderation
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelModeration(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipData>> {
            const localVarAxiosArgs = await TipsApiAxiosParamCreator(configuration).channelModeration(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get tip details
         * @summary /:channel/:tipId
         * @param {string} channel guid - Channel id
         * @param {string} tipId guid - Tip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelTipId(channel: string, tipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipData>> {
            const localVarAxiosArgs = await TipsApiAxiosParamCreator(configuration).channelTipId(channel, tipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List tips
         * @summary /:channel
         * @param {number} offset integer - Starting element
         * @param {number} limit integer - Events per page between 1 and 100
         * @param {string} sort string - Sorting method. Possible values createdAt, -createdAt, donation.amount, -donation.amount, donation.provider, -donation.provider
         * @param {number} tz integer - Timezone number
         * @param {string} username string - Username
         * @param {string} email string - Email address
         * @param {number} after datetime - Start date
         * @param {number} before datetime - End date
         * @param {string} message string - Tip message
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel123456789101112(offset: number, limit: number, sort: string, tz: number, username: string, email: string, after: number, before: number, message: string, channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipData>> {
            const localVarAxiosArgs = await TipsApiAxiosParamCreator(configuration).getChannel123456789101112(offset, limit, sort, tz, username, email, after, before, message, channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get top tippers for channel
         * @summary /:channel/top
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelTop12(channel: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Success64>>> {
            const localVarAxiosArgs = await TipsApiAxiosParamCreator(configuration).getChannelTop12(channel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {NewTip} newTip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannel1234(channel: string, newTip: NewTip, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TipData>> {
            const localVarAxiosArgs = await TipsApiAxiosParamCreator(configuration).postChannel1234(channel, newTip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TipsApi - factory interface
 * @export
 */
export const TipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get tips leaderboard
         * @summary /:channel/leaderboard
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelLeaderboard(channel: string, options?: any): AxiosPromise<void> {
            return TipsApiFp(configuration).channelLeaderboard(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * List tips waiting for moderation
         * @summary /:channel/moderation
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelModeration(channel: string, options?: any): AxiosPromise<TipData> {
            return TipsApiFp(configuration).channelModeration(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tip details
         * @summary /:channel/:tipId
         * @param {string} channel guid - Channel id
         * @param {string} tipId guid - Tip id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelTipId(channel: string, tipId: string, options?: any): AxiosPromise<TipData> {
            return TipsApiFp(configuration).channelTipId(channel, tipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List tips
         * @summary /:channel
         * @param {number} offset integer - Starting element
         * @param {number} limit integer - Events per page between 1 and 100
         * @param {string} sort string - Sorting method. Possible values createdAt, -createdAt, donation.amount, -donation.amount, donation.provider, -donation.provider
         * @param {number} tz integer - Timezone number
         * @param {string} username string - Username
         * @param {string} email string - Email address
         * @param {number} after datetime - Start date
         * @param {number} before datetime - End date
         * @param {string} message string - Tip message
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel123456789101112(offset: number, limit: number, sort: string, tz: number, username: string, email: string, after: number, before: number, message: string, channel: string, options?: any): AxiosPromise<TipData> {
            return TipsApiFp(configuration).getChannel123456789101112(offset, limit, sort, tz, username, email, after, before, message, channel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get top tippers for channel
         * @summary /:channel/top
         * @param {string} channel guid - Channel id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelTop12(channel: string, options?: any): AxiosPromise<Array<Success64>> {
            return TipsApiFp(configuration).getChannelTop12(channel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /:channel
         * @param {string} channel guid - Channel id
         * @param {NewTip} newTip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannel1234(channel: string, newTip: NewTip, options?: any): AxiosPromise<TipData> {
            return TipsApiFp(configuration).postChannel1234(channel, newTip, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TipsApi - object-oriented interface
 * @export
 * @class TipsApi
 * @extends {BaseAPI}
 */
export class TipsApi extends BaseAPI {
    /**
     * Get tips leaderboard
     * @summary /:channel/leaderboard
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipsApi
     */
    public channelLeaderboard(channel: string, options?: any) {
        return TipsApiFp(this.configuration).channelLeaderboard(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List tips waiting for moderation
     * @summary /:channel/moderation
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipsApi
     */
    public channelModeration(channel: string, options?: any) {
        return TipsApiFp(this.configuration).channelModeration(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tip details
     * @summary /:channel/:tipId
     * @param {string} channel guid - Channel id
     * @param {string} tipId guid - Tip id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipsApi
     */
    public channelTipId(channel: string, tipId: string, options?: any) {
        return TipsApiFp(this.configuration).channelTipId(channel, tipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List tips
     * @summary /:channel
     * @param {number} offset integer - Starting element
     * @param {number} limit integer - Events per page between 1 and 100
     * @param {string} sort string - Sorting method. Possible values createdAt, -createdAt, donation.amount, -donation.amount, donation.provider, -donation.provider
     * @param {number} tz integer - Timezone number
     * @param {string} username string - Username
     * @param {string} email string - Email address
     * @param {number} after datetime - Start date
     * @param {number} before datetime - End date
     * @param {string} message string - Tip message
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipsApi
     */
    public getChannel123456789101112(offset: number, limit: number, sort: string, tz: number, username: string, email: string, after: number, before: number, message: string, channel: string, options?: any) {
        return TipsApiFp(this.configuration).getChannel123456789101112(offset, limit, sort, tz, username, email, after, before, message, channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get top tippers for channel
     * @summary /:channel/top
     * @param {string} channel guid - Channel id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipsApi
     */
    public getChannelTop12(channel: string, options?: any) {
        return TipsApiFp(this.configuration).getChannelTop12(channel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /:channel
     * @param {string} channel guid - Channel id
     * @param {NewTip} newTip 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TipsApi
     */
    public postChannel1234(channel: string, newTip: NewTip, options?: any) {
        return TipsApiFp(this.configuration).postChannel1234(channel, newTip, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List channel\'s access list
         * @summary /access
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        access: async (accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling access.');
            }
            const localVarPath = `/users/access`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Add Description
         * @summary /channels
         * @param {string} type 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channels: async (type: string, accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling channels.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling channels.');
            }
            const localVarPath = `/users/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current user channel
         * @summary /current
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        current: async (accept: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling current.');
            }
            const localVarPath = `/users/current`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List channel\'s access list
         * @summary /access
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async access(accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelUsers>>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).access(accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * TODO: Add Description
         * @summary /channels
         * @param {string} type 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channels(type: string, accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).channels(type, accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Current user channel
         * @summary /current
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async current(accept: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success67>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).current(accept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List channel\'s access list
         * @summary /access
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        access(accept: string, options?: any): AxiosPromise<Array<ChannelUsers>> {
            return UsersApiFp(configuration).access(accept, options).then((request) => request(axios, basePath));
        },
        /**
         * TODO: Add Description
         * @summary /channels
         * @param {string} type 
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channels(type: string, accept: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).channels(type, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Current user channel
         * @summary /current
         * @param {string} accept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        current(accept: string, options?: any): AxiosPromise<Success67> {
            return UsersApiFp(configuration).current(accept, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * List channel\'s access list
     * @summary /access
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public access(accept: string, options?: any) {
        return UsersApiFp(this.configuration).access(accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * TODO: Add Description
     * @summary /channels
     * @param {string} type 
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public channels(type: string, accept: string, options?: any) {
        return UsersApiFp(this.configuration).channels(type, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current user channel
     * @summary /current
     * @param {string} accept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public current(accept: string, options?: any) {
        return UsersApiFp(this.configuration).current(accept, options).then((request) => request(this.axios, this.basePath));
    }

}


